{
    "id": "french-anime-online-streaming",
    "name": "FR | French Anime",
    "version": "1.0.2",
    "manifestURI": "https://raw.githubusercontent.com/TropicalFrog3/seanime-extension/refs/heads/main/online-streaming/french-anime/manifest.json",
    "language": "typescript",
    "type": "onlinestream-provider",
    "description": "French Anime est une extension Seanime en français qui permet de regarder des anime dans le catalogue du site french-anime.com.",
    "author": "TropicalFrog3",
    "icon": "https://raw.githubusercontent.com/TropicalFrog3/seanime-extension/refs/heads/main/online-streaming/french-anime/favicon.png",
    "lang": "fr",
    "payload": "/// \u003creference path=\"../_external/.onlinestream-provider.d.ts\" /\u003e\n/// \u003creference path=\"../_external/core.d.ts\" /\u003e\n\n//#region console\n\nconst DevMode = true;\nconst originalConsoleLog = console.log;\nconsole.log = function (...args: any[]) {\n    if (DevMode) {\n        originalConsoleLog.apply(console, args);\n    }\n};\n\n//#endregion\n\n//#region types\n\ntype MovieJson = {\n    title: string,\n    link: string,\n    nbEp: number,\n    SeasonOrFilm: SorF,\n    details: MovieDetails,\n}\n\ntype SorF = \"saison\" | \"film\";\n\ntype MovieDetails = {\n    synopsis: string,\n    director: string,\n    actors: string[],\n    releaseDate: string,\n    version: string,\n}\n\nenum ScoreWeight {\n    // query\n    Title = 3.6,\n    // dub\n    Language = 2.5,\n    // media.format\n    SeasonOrFilm = 2.1,\n    // year\n    ReleaseDate = 1,\n    // media.episodeCount\n    EpisodeCount = 1,\n\n    MaxScore = 10,\n}\n\n//#endregion\n\nclass Provider {\n\n    //#region variables\n\n    readonly SEARCH_URL_2 = \"https://french-anime.com/\u0026do=search\u0026subaction=search\u0026story=\";\n    readonly SEARCH_URL_3 = \"https://french-anime.com/\";\n    // idk yet how to get the api url of seanime, so i just hardcoded it\n    readonly SEANIME_API = \"http://127.0.0.1:43211/api/v1/proxy?url=\";\n\n    _Server = \"\";\n\n    //#endregion\n\n    //#region methods\n\n    getSettings(): Settings {\n        return {\n            episodeServers: [\n                \"vidmoly\", \"jilliandescribecompany\", \"luluvid\", \"uqload\", \"filelions\", \"getvid\", \"sibnet\", \"ups2up\",\n                \"myvi\", \"mixdrop\", \"ok\", \"mail\", \"iframedream\", \"rutube\", \"fembed\", \"mp4upload\", \"gvstream\", \"gvlod\", \"upvid\", \"dood\",\n                \"ninjastream\", \"streamtape\", \"vudeo\", \"sbfast\", \"streamlare\", \"sbfull\", \"sbthe\", \"upstream\", \"vvide0\", \"hqq\", \"mvidoo\", \"vido\",\n                \"sbspeed\", \"sblanh\", \"upvideo\", \"streamvid\", \"streamhide\", \"lvturbo\", \"guccihide\", \"likessb\", \"streamhub\"\n            ],\n            supportsDub: true,\n        }\n    }\n\n    //#endregion\n\n    //#region utility\n\n    private getWordVector(word: string): number[] {\n        // Dummy implementation: convert word to a vector of character codes\n        // I'll probably change it one in an other update\n        return Array.from(word).map(char =\u003e char.charCodeAt(0));\n    }\n\n    private cosineSimilarity(vec1: number[], vec2: number[]): number {\n        const dotProduct = vec1.reduce((sum, val, i) =\u003e sum + val * (vec2[i] || 0), 0);\n        const magnitude1 = Math.sqrt(vec1.reduce((sum, val) =\u003e sum + val * val, 0));\n        const magnitude2 = Math.sqrt(vec2.reduce((sum, val) =\u003e sum + val * val, 0));\n        return magnitude1 \u0026\u0026 magnitude2 ? dotProduct / (magnitude1 * magnitude2) : 0;\n    }\n\n    private getWordSimilarity(word1: string, words: string[]): number {\n        const word1Vector = this.getWordVector(word1);\n        let maxSimilarity = 0;\n\n        for (const word2 of words) {\n            const word2Vector = this.getWordVector(word2);\n            const similarity = this.cosineSimilarity(word1Vector, word2Vector);\n            maxSimilarity = Math.max(maxSimilarity, similarity);\n        }\n\n        return maxSimilarity;\n    }\n\n    private scoreStringMatch(weight: ScoreWeight, text: string | undefined, query: string | undefined): number {\n        // Simple scoring mechanism: \n        // +2 point if it the same\n        // split into words: \n        //      TOTAL: +2/nb words\n        //          -0% point to total per exact word match (case insensitive)\n        //          -5% point to total if word query and word text have 80% similarity\n        //          -10% point to total if word query and word text have 50% similarity\n        //          -15% point to total if word query and word text have 30% similarity\n        //          -20% point to total if word query and word text have 10% similarity\n        //          -100% point to total if word query and word text have 0% similarity\n        // Higher score means better match\n        // below 0 means no match, Warn all my test were correct, but i didn't test them all\n\n        if (!text || !query) return 0;\n\n        text = text.toLowerCase();\n        query = query.toLowerCase();\n\n        let score = 0;\n        if (text === query)\n            return ScoreWeight.MaxScore * weight;\n\n        const textWords = text.split(\" \");\n        const queryWords = query.split(\" \");\n\n        for (const word of queryWords) {\n            if (textWords.includes(word)) {\n                score += ScoreWeight.MaxScore / textWords.length;\n            }\n            else {\n                const similarity = this.getWordSimilarity(word, textWords);\n                score -= similarity * ScoreWeight.MaxScore / textWords.length;\n            }\n        }\n\n        return score * weight;\n    }\n\n    private findBestTitle(movies: MovieJson[], opts: SearchOptions): MovieJson | undefined {\n        let bestScore = 0;\n        let bestMovie: MovieJson | undefined;\n\n        for (const movie of movies) {\n            let score: number = 0;\n            let balance: number = 0;\n            let strOutput = \"\"\n            // TITLE\n            score += this.scoreStringMatch(ScoreWeight.Title, movie.title, opts.query);\n            strOutput += `Title: ${movie.title} VS ${opts.query}, Current Score: ${score}\\n`;\n\n            // Gerer au elementtojson\n            // // LANGUAGE\n            // const queryLang = opts.dub ? \"FRENCH\" : \"VOSTFR\";\n            // const LangScore = this.scoreStringMatch(ScoreWeight.Language, movie.details.version, queryLang);\n            // score = score + LangScore;\n            // strOutput += `Language: ${movie.details.version} VS ${queryLang}, Score: ${LangScore}\\n`;\n\n            // Gerer au elementtojson\n            // // SEASON OR FILM\n            // const queryFormat = opts.media.format === \"MOVIE\" ? \"Film\" : \"Saison\";\n            // const FormatScore = this.scoreStringMatch(ScoreWeight.SeasonOrFilm, movie.SeasonOrFilm, queryFormat);\n            // score = score + FormatScore;\n            // strOutput += `Format: ${movie.SeasonOrFilm} VS ${queryFormat}, Score: ${FormatScore}\\n`;\n\n            // RELEASE DATE\n            const queryReleaseDate = opts.year?.toString();\n            if(queryReleaseDate)\n            {\n                score += this.scoreStringMatch(ScoreWeight.ReleaseDate, movie.details.releaseDate, queryReleaseDate);\n                strOutput += `Release Date: ${movie.details.releaseDate} VS ${queryReleaseDate}, Current Score: ${score}\\n`;\n            }\n            else\n                balance++;\n            \n            // EPISODE COUNT\n            const queryEpisodeCount = opts.media.episodeCount?.toString();\n            if(queryEpisodeCount)\n            {\n                score += this.scoreStringMatch(ScoreWeight.EpisodeCount, movie.nbEp.toString(), queryEpisodeCount);\n                strOutput += `Episode Count: ${movie.nbEp} VS ${queryEpisodeCount}, Current Score: ${score}\\n`;\n            }\n            else\n                balance++;\n            \n            if(balance \u003e 0)\n            {\n                // without balance it is 3/3\n                // with balance it is 3/2\n                // need to balance to /3\n                score = score * (3 / (3 - balance));\n            }\n\n            console.log(`Movie: ${movie.title}\\n${strOutput}Total Score: ${score}\\n--------------------`);\n\n            if (score \u003e bestScore) {\n                bestScore = score;\n                bestMovie = movie;\n            }\n        }\n\n        if (bestMovie) {\n            console.log(\"Best movie found:\", bestMovie.title);\n            return bestMovie;\n        }\n        return undefined;\n    }\n\n    private async findMediaUrls(type: VideoSourceType, html, serverUrl: string, resolutionMatch?: RegExpMatchArray, unpacked?: string): Promise\u003cVideoSource[] | VideoSource | undefined\u003e {\n\n        const regex = new RegExp('https?:\\\\/\\\\/[^\\'\"]+\\\\.' + type + '(?:\\\\?[^\\\\s\\'\"]*)?(?:#[^\\\\s\\'\"]*)?', 'g');\n\n        let VideoMatch = html.match(regex)\n        || unpacked?.match(regex)\n        || html.match(new RegExp(`\"([^\"]+\\\\.${type})\"`, \"g\")) \n        || unpacked?.match(new RegExp(`\"([^\"]+\\\\.${type})\"`, \"g\"));\n\n        if (VideoMatch) {\n            if (!VideoMatch.some(url =\u003e url.startsWith(\"http\"))) {\n                const serverurldomain = serverUrl.split(\"/\").slice(0, 3).join(\"/\");\n                VideoMatch = VideoMatch.map(url =\u003e `${serverurldomain}${url}`.replaceAll(`\"`, \"\"));\n            }\n\n            if (VideoMatch.length \u003e 1) {\n                // If found multiple, euhm we are cooked... idk yet let me think of it lmao\n                console.warn(\"Found multiple m3u8 URLs:\", VideoMatch);\n                // for now take the first one idk\n                VideoMatch.forEach(element =\u003e {\n                    if (VideoMatch[0] !== element) {\n                        VideoMatch.pop();\n                    }\n                });\n            }\n            else {\n                console.log(\"Found m3u8 URL:\", VideoMatch[0]);\n            }\n\n            if (VideoMatch[0].includes(`master.${type}`)) {\n                // fetch the match to see if the m3u8 is main or extension\n                // get the referer of the ServerUrl\n                const ref = serverUrl.split(\"/\").slice(0, 3).join(\"/\");\n                const req = await fetch(`${this.SEANIME_API}${encodeURIComponent(VideoMatch[0])}`);\n                let reqHtml = await req.text();\n                reqHtml = decodeURIComponent(reqHtml);\n                let qual = \"\";\n                let url = \"\";\n                const videos: VideoSource[] = [];\n                if (reqHtml.includes(\"#EXTM3U\")) {\n                    reqHtml.split(\"\\n\").forEach(line =\u003e {\n                        if (line.startsWith(\"#EXT-X-STREAM-INF\")) {\n                            qual = line.split(\"RESOLUTION=\")[1]?.split(\",\")[0] || \"unknown\";\n                            const height = parseInt(qual.split(\"x\")[1]) || 0;\n\n                            if (height \u003e= 1080) {\n                                qual = \"1080p\";\n                            } else if (height \u003e= 720) {\n                                qual = \"720p\";\n                            } else if (height \u003e= 480) {\n                                qual = \"480p\";\n                            } else if (height \u003e= 360) {\n                                qual = \"360p\";\n                            } else {\n                                qual = \"unknown\";\n                            }\n                        }\n                        else if (line.startsWith(\"/api/v1/proxy?url=http\")) {\n                            url = line.replace(\"/api/v1/proxy?url=\", \"\");\n                        }\n\n                        if (url \u0026\u0026 qual) {\n                            videos.push({\n                                url: url,\n                                type: type,\n                                quality: `${this._Server} - ${qual}`,\n                                subtitles: []\n                            })\n                            url = \"\";\n                            qual = \"\";\n                        }\n                    });\n                }\n\n                if (videos.length \u003e 0) {\n                    return videos.sort((a, b) =\u003e {\n                        const resolutionOrder = [\"1080p\", \"720p\", \"480p\", \"360p\", \"unknown\"];\n                        const aIndex = resolutionOrder.indexOf(a.quality.split(\" \")[2]);\n                        const bIndex = resolutionOrder.indexOf(b.quality.split(\" \")[2]);\n                        return aIndex - bIndex;\n                    });\n                }\n                else {\n                    console.warn(\"m3u8 master is not in a correct format\")\n                }\n            }\n            else {\n                console.warn(\"No master m3u8 URL found\");\n            }\n\n            return {\n                url: VideoMatch[0],\n                quality: resolutionMatch ? resolutionMatch[1] : `${this._Server} - unknown`,\n                type: type,\n                subtitles: []\n            };\n        }\n\n        return undefined;\n    }\n\n    private async HandleServerUrl(serverUrl: string): Promise\u003cVideoSource[] | VideoSource\u003e {\n\n        const req = await fetch(`${this.SEANIME_API}${encodeURIComponent(serverUrl)}`);\n        if (!req.ok) {\n            console.log(\"Failed to fetch server URL:\", serverUrl, \"Status:\", req.status);\n            return [];\n        }\n\n        const html = await req.text();\n\n        // special case Dean Edwards’ Packer\n        // .match(/eval\\(function\\(p,a,c,k,e,d\\)(.*?)\\)\\)/s);\n        function unpack(p, a, c, k) { while (c--) if (k[c]) p = p.replace(new RegExp('\\\\b' + c.toString(a) + '\\\\b', 'g'), k[c]); return p }\n        // regex is weird here so i did it manually\n        function extractScripts(str: string): string[] {\n            const results: string[] = [];\n            const openTag = \"\u003cscript type='text/javascript'\u003e\";\n            const closeTag = \"\u003c/script\u003e\";\n\n            let pos = 0;\n\n            while (pos \u003c str.length) {\n                const start = str.indexOf(openTag, pos);\n                if (start === -1) break;\n                const end = str.indexOf(closeTag, start);\n                if (end === -1) break;\n                const content = str.substring(start + openTag.length, end);\n                results.push(content);\n                pos = end + closeTag.length;\n            }\n\n            return results;\n        }\n\n        let unpacked;\n        const scriptContents = extractScripts(html);\n        for (const c of scriptContents) {\n            let c2 = c;\n            // change c for each 200 char put \\n (it too long)\n            for (let j = 0; j \u003c c.length; j += 900) {\n                c2 = c2.substring(0, j) + \"\\n\" + c2.substring(j);\n            }\n            if (c.includes(\"eval(function(p,a,c,k,e,d)\")) {\n\n                console.log(\"Unpacked has been found.\");\n                const fullRegex = /eval\\(function\\([^)]*\\)\\{[\\s\\S]*?\\}\\(\\s*'([\\s\\S]*?)'\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*'([\\s\\S]*?)'\\.split\\('\\|'\\)/;\n                const match = c2.match(fullRegex);\n\n                if (match) {\n                    const packed = match[1];\n                    const base = parseInt(match[2], 10);\n                    const count = parseInt(match[3], 10);\n                    const dict = match[4].split('|');\n\n                    unpacked = unpack(packed, base, count, dict);\n                    // decode unicode example \\uXXXX\n                    unpacked = unpacked.replace(/\\\\u([\\d\\w]{4})/gi, (_, grp) =\u003e String.fromCharCode(parseInt(grp, 16)))\n                        .replace(/%3C/g, '\u003c').replace(/%3E/g, '\u003e')\n                        .replace(/%3F/g, '?')\n                        .replace(/%3A/g, ':')\n                        .replace(/%2C/g, ',')\n                        .replace(/%2F/g, '/')\n                        .replace(/%2B/g, '+')\n                        .replace(/%20/g, ' ')\n                        .replace(/%21/g, '!')\n                        .replace(/%22/g, '\"')\n                        .replace(/%27/g, \"'\")\n                        .replace(/%28/g, '(').replace(/%29/g, ')')\n                        .replace(/%3B/g, ';');\n                }\n            }\n        }\n\n        // look for resolution: [4 to 3 numbers]p, have \" or [space] after p if its the [space] it must be between to [space]\n        // example: 1080p\" or 1080p\n        const resolutionMatch = html.match(/(\\d{3,4})p(?=[\" ])/) || unpacked?.match(/(\\d{3,4})p(?=[\" ])/);\n        if (resolutionMatch) {\n            const resolution = resolutionMatch[1];\n            console.log(\"Found resolution:\", resolution);\n        }\n\n        // look for .m3u8\n        const m3u8Videos = await this.findMediaUrls(\"m3u8\", html, serverUrl, resolutionMatch, unpacked);\n        if (m3u8Videos !== undefined) {\n            console.log(\"Found m3u8: \", m3u8Videos);\n            return m3u8Videos;\n        }\n\n        // look for .mp4 do the same as .m3u8\n        const mp4Videos = await this.findMediaUrls(\"mp4\", html, serverUrl, resolutionMatch, unpacked);\n        if (mp4Videos !== undefined) {\n            console.log(\"Found mp4: \", mp4Videos);\n            return mp4Videos;\n        }\n\n        console.warn(\"No m3u8 or mp4 URLs found in the server URL:\", serverUrl, \". Make sure this is true.\");\n        return [];\n    }\n\n    private parseMovieElement(\n        el: DocSelection,\n        opts: SearchOptions,\n        seasonNumberOpts?: number\n    ): MovieJson | undefined {\n        const nbEpisodes = parseInt(el.find(\"div.mov-m\").text().trim(), 10) || 0;\n        const titleLink = el.find(\"a.mov-t.nowrap\");\n        const title = titleLink.text().trim();\n        const link = titleLink.attr(\"href\") || \"\";\n\n        const bloc1_2 = el.find(\"div.nbloc1-2\");\n        const SeasonOrFilm: SorF =\n            bloc1_2.find(\"span.block-sai\").length() \u003e 0 ? \"saison\" : \"film\";\n\n        // Extract season number if applicable\n        const words = bloc1_2\n            .find(\"span.block-sai\")\n            .text()\n            .trim()\n            .replaceAll(`\\t`, \"\")\n            .replaceAll(`\\n`, \"\")\n            .split(\" \")\n            .filter((word) =\u003e word !== \"\");\n\n        const seasonNumber = SeasonOrFilm === \"saison\" ? parseInt(words[1]) : 0;\n\n        const details: MovieDetails = {\n            synopsis: \"\",\n            director: \"\",\n            actors: [],\n            releaseDate: \"\",\n            version: \"\",\n        };\n\n        const movieLine = el.find(\"ul.movie-lines li\");\n        movieLine.each((i, line) =\u003e {\n            const text = line.text().trim().toLocaleLowerCase();\n            const cat = text.split(\":\")[0].trim();\n            switch (cat) {\n                case \"synopsis\":\n                    details.synopsis = text.replace(\"synopsis:\", \"\").trim();\n                    break;\n                case \"date de sortie\":\n                    details.releaseDate = text.replace(\"date de sortie:\", \"\").trim();\n                    break;\n                case \"réalisateur\":\n                    details.director = text.replace(\"réalisateur:\", \"\").trim();\n                    break;\n                case \"acteurs\":\n                    details.actors = text.replace(\"acteurs:\", \"\").trim().split(\", \");\n                    break;\n                case \"version\":\n                    details.version = text.replace(\"version:\", \"\").trim();\n                    break;\n            }\n        });\n\n        if (\n            !title ||\n            details.version.toLocaleLowerCase() !== (opts.dub ? \"french\" : \"vostfr\") ||\n            SeasonOrFilm.toLocaleLowerCase() !==\n            (opts.media.format === \"MOVIE\" ? \"film\" : \"saison\")\n        ) {\n            return undefined;\n        }\n\n\n        if (seasonNumber \u0026\u0026 seasonNumberOpts \u0026\u0026 seasonNumber !== seasonNumberOpts) {\n            return undefined;\n        }\n\n        return {\n            title,\n            link,\n            nbEp: nbEpisodes,\n            SeasonOrFilm,\n            details,\n        };\n    }\n\n    //#endregion\n\n    //#region main\n\n    async search(opts: SearchOptions): Promise\u003cSearchResult[]\u003e {\n        // why the f*ck dan da dan s1 is not in the search lmao\n        const moviesJson: MovieJson[] = [];\n        let tempquery = opts.query;\n\n        const queryEnglish = opts.media.englishTitle || opts.query;\n        const seasonMatch = queryEnglish.toLowerCase().match(/season\\s*(\\d+)/i);\n        let seasonNumberOpts;\n        if (seasonMatch) {\n            seasonNumberOpts = parseInt(seasonMatch[1], 10);\n            console.log(\"Found season number:\", seasonNumberOpts);\n        }\n        else {\n            seasonNumberOpts = 1;\n        }\n\n        while (tempquery !== \"\") {\n            console.log(`Searching for query: \"${tempquery}\".`);\n            const html = await fetch(this.SEARCH_URL_2 + encodeURIComponent(tempquery), {\n                method: \"POST\",\n            }).then(res =\u003e res.text());\n            const $ = await LoadDoc(html);\n            const movies = $(\"#dle-content\").find(\"div.mov.clearfix\");\n            if (movies.length() \u003c= 0) {\n                tempquery = tempquery.split(/[\\s:']+/).slice(0, -1).join(\" \");\n                continue;\n            }\n            const parsedmovies = movies.map((_, el) =\u003e this.parseMovieElement(el, opts, seasonNumberOpts));\n            const filteredMovies = parsedmovies.filter(m =\u003e m !== undefined \u0026\u0026 m !== null);\n            moviesJson.push(...filteredMovies);\n\n            const pagination = $(\"#dle-content\").find(\".search-page .berrors\").text().trim();\n            console.log(\"Pagination info:\", pagination);\n            if (pagination.includes(\"Résultats de la requête\")) {\n                const numbers = pagination.match(/\\d+/g);\n                if (numbers \u0026\u0026 numbers.length \u003e= 3) {\n                    const TotalResults = parseInt(numbers[0], 10);\n                    const CurrentPage = parseInt(numbers[1], 10);\n                    const ResultsFrom = parseInt(numbers[2], 10);\n                    console.log(`Total results: ${TotalResults}, Current page: ${CurrentPage}, Results from: ${ResultsFrom}`);\n\n                    const resultsPerPage = 10;\n                    const totalPages = Math.ceil(TotalResults / resultsPerPage);\n                    console.log(`Total results: ${TotalResults}, Total pages: ${totalPages}`);\n                    for (let i = 2; i \u003c= totalPages; i++) {\n                        const url = `${this.SEARCH_URL_3}?do=search\u0026subaction=search\u0026search_start=${(i)}\u0026full_search=0\u0026result_from=${ResultsFrom}\u0026story=${encodeURIComponent(tempquery)}`;\n                        console.log(`Fetching page ${i}... with url ${url}`);\n                        const html = await fetch(url, {\n                            method: \"POST\",\n                        }).then(res =\u003e res.text());\n                        const $$ = await LoadDoc(html);\n                        const movies2 = $$(\"#dle-content\").find(\"div.mov.clearfix\");\n                        const parsedmovies2 = movies2.map((_, el) =\u003e this.parseMovieElement(el, opts, seasonNumberOpts));\n                        const filteredMovies2 = parsedmovies2.filter(m =\u003e m !== undefined \u0026\u0026 m !== null);\n                        moviesJson.push(...filteredMovies2);\n                    }\n                }\n            }\n\n            if (movies.length() \u003e 0) {\n                break;\n            }\n        }\n\n\n        if (moviesJson \u0026\u0026 moviesJson.length \u003e 0) {\n            console.log(`Found ${moviesJson.length} movies matching the criteria with query: ${opts.query}`);\n\n            const bestMovie = this.findBestTitle(moviesJson, opts);\n            if (bestMovie) {\n                return \u003cSearchResult[]\u003e[{\n                    id: bestMovie?.link,\n                    title: bestMovie?.title,\n                    url: bestMovie?.link,\n                    subOrDub: opts.dub ? \"dub\" : \"sub\",\n                }];\n            }\n        }\n\n        const newQuery = tempquery !== \"\" ? tempquery.split(/[\\s:']+/).slice(0, -1).join(\" \") : \"\";\n        if (tempquery === \"\" || newQuery === \"\") {\n            console.warn(\"No movies matched the dub and format criteria.\")\n            return [];\n        }\n\n        console.log(\"retrying with query:\", newQuery);\n        const newresults = await this.search({\n            query: newQuery,\n            dub: opts.dub,\n            media: opts.media\n        });\n\n        if (newresults \u0026\u0026 newresults.length \u003e 0) {\n            return newresults;\n        }\n        return [];\n    }\n\n    async findEpisodes(id: string): Promise\u003cEpisodeDetails[]\u003e {\n\n        const $ = await fetch(id).then(res =\u003e res.text()).then(LoadDoc);\n\n        const results: EpisodeDetails[] = [];\n        let ServerToAdd: string[] = [];\n\n        const eps = $(\"div[class='eps']\").text().trim().split(\"\\n\").filter(line =\u003e line.trim() !== \"\");\n        eps.forEach(line =\u003e {\n            const [episodeNumber, ...urls] = line.split(\"!\");\n            urls.forEach(url =\u003e {\n                results.push({\n                    // if url last character is a , remove it\n                    id: url.trim().replace(/,$/, \"\"),\n                    url: id,\n                    number: parseInt(episodeNumber.trim())\n                });\n                // DEV CHECK TO FIND MISSING SERVERS\n                if (DevMode) {\n                    for (const element of url.trim().replace(/,$/, \"\").split(\",\")) {\n                        // get the server name of the element\n                        const parts = element.split(\"/\");\n\n                        const PartsServerName = parts[2] ? parts[2].split(\".\") : [];\n                        const serverName = PartsServerName.length \u003e= 3 ? PartsServerName[1] : PartsServerName[0];\n                        // check if servername is in the list of the episode servers\n                        if (serverName !== undefined \u0026\u0026 !this.getSettings().episodeServers.includes(serverName) \u0026\u0026 !ServerToAdd.includes(serverName)) {\n                            ServerToAdd.push(serverName);\n                        }\n                    }\n                }\n            });\n        });\n\n        if (ServerToAdd.length \u003e 0) {\n            console.warn(`Need to add server: \"${ServerToAdd.join(`\",\"`)}\"`);\n            this.getSettings().episodeServers.push(...ServerToAdd);\n        }\n\n        return results;\n    }\n\n    async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise\u003cEpisodeServer\u003e {\n        // TODO: FIX vvide0 (its dood stream servers): 171018\n        this._Server = _server;\n        const servers = episode.id.split(\",\");\n        // get the right url server\n        const serverUrl = servers.find(server =\u003e server.includes(_server));\n        const videoSources = \u003cVideoSource[]\u003e[];\n        if (serverUrl \u0026\u0026 _server !== \"\") {\n            console.log(`Handling server URL: ${serverUrl}`);\n            const result = await this.HandleServerUrl(serverUrl);\n            if (Array.isArray(result)) {\n                videoSources.push(...result);\n            } else {\n                videoSources.push(result);\n            }\n        }\n        else {\n            console.log(`Server not found: ${_server}\\n Try with these servers:\\n- ${servers.map(url =\u003e {\n                const parts = url.split(\"/\");\n                const partsServerName = parts[2] ? parts[2].split(\".\") : [];\n                const serverName = partsServerName.length \u003e= 3 ? partsServerName[1] : partsServerName[0];\n                return serverName;\n            }).join(\"\\n- \")}`);\n            if (servers.includes(_server)) {\n                return \u003cEpisodeServer\u003e{\n                    headers: {},\n                    server: _server + \" (video not found)\",\n                    videoSources: \u003cVideoSource[]\u003e[\n                        {\n                            // dummy video source\n                            url: \"https://devstreaming-cdn.apple.com/videos/streaming/examples/img_bipbop_adv_example_fmp4/master.m3u8\",\n                            type: \"m3u8\",\n                            quality: \"video not found\",\n                            subtitles: []\n                        }\n                    ]\n\n                };\n            } else {\n                return \u003cEpisodeServer\u003e{\n                    headers: {},\n                    server: \"\",\n                    videoSources: []\n                };\n            }\n\n        }\n\n        if (videoSources.length \u003e 0) {\n            const ref = serverUrl.split(\"/\").slice(0, 3).join(\"/\");\n            return {\n                headers: {\n                    referer: ref\n                },\n                server: _server,\n                videoSources: videoSources\n            };\n        }\n        else {\n            console.log(`No video sources found for server: ${_server}`);\n            return \u003cEpisodeServer\u003e{\n                headers: {},\n                server: _server + \" (video not found)\",\n                videoSources: \u003cVideoSource[]\u003e[\n                    {\n                        url: \"https://devstreaming-cdn.apple.com/videos/streaming/examples/img_bipbop_adv_example_fmp4/master.m3u8\",\n                        type: \"m3u8\",\n                        quality: \"video not found\",\n                        subtitles: []\n                    }\n                ]\n\n            };\n        }\n    }\n\n    //#endregion\n}"
}
