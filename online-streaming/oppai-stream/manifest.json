{
    "id": "oppai-stream-online-streaming",
    "name": "EN | Oppai Stream (18+)",
    "version": "1.0.0",
    "manifestURI": "https://raw.githubusercontent.com/TropicalFrog3/seanime-extension/refs/heads/main/online-streaming/oppai-stream/manifest.json",
    "language": "typescript",
    "type": "onlinestream-provider",
    "description": "Provides seamless integration with the oppai.stream catalog for online streaming within Seanime, enabling users to watch available titles directly from the platform.",
    "author": "TropicalFrog3",
    "icon": "https://raw.githubusercontent.com/TropicalFrog3/seanime-extension/refs/heads/main/online-streaming/oppai-stream/favicon.png",
    "website": "",
    "lang": "en",
    "payload": "/// \u003creference path=\"../_external/.onlinestream-provider.d.ts\" /\u003e\n/// \u003creference path=\"../_external/core.d.ts\" /\u003e\n\n//#region console\n\nconst DevMode = false;\nconst originalConsoleLog = console.log;\nconsole.log = function (...args: any[]) {\n    if (DevMode) {\n        originalConsoleLog.apply(console, args);\n    }\n};\n\n//#endregion\n\n//#region types\n\nenum ScoreWeight {\n    // query\n    Title = 3.6,\n    // dub\n    Language = 2.5,\n    // media.format\n    SeasonOrFilm = 2.1,\n    // year\n    ReleaseDate = 1,\n    // media.episodeCount\n    EpisodeCount = 1,\n\n    MaxScore = 10,\n}\n\nconst languageMap: Record\u003cstring, string\u003e = {\n    \"en\": \"English\",\n    \"eng\": \"English\",\n    \"es\": \"Spanish\",\n    \"spa\": \"Spanish\",\n    \"fr\": \"French\",\n    \"it\": \"Italian\",\n    \"ja\": \"Japanese\",\n    \"jp\": \"Japanese\",\n};\n\n//#endregion\n\nclass Provider {\n\n    //#region variables\n\n    readonly SEARCH_URL = \"https://oppai.stream/actions/search.php?order=recent\u0026page=1\u0026limit=35\u0026genres=\u0026blacklist=\u0026studio=\u0026ibt=0\u0026swa=1\u0026text=\";\n    // idk yet how to get the api url of seanime, so i just hardcoded it\n    readonly SEANIME_API = \"http://127.0.0.1:43211/api/v1/proxy?url=\";\n\n    _Server = \"\";\n\n    //#endregion\n\n    //#region methods\n\n    getSettings(): Settings {\n        return {\n            // i don't think they have more server...\n            episodeServers: [\n                \"oppai.stream\"\n            ],\n            supportsDub: false,\n        }\n    }\n\n    //#endregion\n\n    //#region utility\n\n    private getWordVector(word: string): number[] {\n        // Dummy implementation: convert word to a vector of character codes\n        // I'll probably change it one in an other update\n        return Array.from(word).map(char =\u003e char.charCodeAt(0));\n    }\n\n    private cosineSimilarity(vec1: number[], vec2: number[]): number {\n        const dotProduct = vec1.reduce((sum, val, i) =\u003e sum + val * (vec2[i] || 0), 0);\n        const magnitude1 = Math.sqrt(vec1.reduce((sum, val) =\u003e sum + val * val, 0));\n        const magnitude2 = Math.sqrt(vec2.reduce((sum, val) =\u003e sum + val * val, 0));\n        return magnitude1 \u0026\u0026 magnitude2 ? dotProduct / (magnitude1 * magnitude2) : 0;\n    }\n\n    private getWordSimilarity(word1: string, words: string[]): number {\n        const word1Vector = this.getWordVector(word1);\n        let maxSimilarity = 0;\n\n        for (const word2 of words) {\n            const word2Vector = this.getWordVector(word2);\n            const similarity = this.cosineSimilarity(word1Vector, word2Vector);\n            maxSimilarity = Math.max(maxSimilarity, similarity);\n        }\n\n        return maxSimilarity;\n    }\n\n    private scoreStringMatch(weight: number, text: string | undefined, query: string | undefined): number {\n        // Simple scoring mechanism: \n        // +2 point if it the same\n        // split into words: \n        //      TOTAL: +2/nb words\n        //          -0% point to total per exact word match (case insensitive)\n        //          -5% point to total if word query and word text have 80% similarity\n        //          -10% point to total if word query and word text have 50% similarity\n        //          -15% point to total if word query and word text have 30% similarity\n        //          -20% point to total if word query and word text have 10% similarity\n        //          -100% point to total if word query and word text have 0% similarity\n        // Higher score means better match\n        // below 0 means no match, Warn all my test were correct, but i didn't test them all\n\n        if (!text || !query) return 0;\n\n        text = text.toLowerCase();\n        query = query.toLowerCase();\n\n        let score = 0;\n        if (text === query)\n            return ScoreWeight.MaxScore * weight;\n\n        const textWords = text.split(\" \");\n        const queryWords = query.split(\" \");\n\n        for (const word of queryWords) {\n            if (textWords.includes(word)) {\n                score += ScoreWeight.MaxScore / textWords.length;\n            }\n            else {\n                const similarity = this.getWordSimilarity(word, textWords);\n                score -= similarity * ScoreWeight.MaxScore / textWords.length;\n            }\n        }\n\n        return score * weight;\n    }\n\n    private findBestTitle(movies: { Title: string; Url: string }[], opts: string): { Title: string; Url: string } | undefined {\n        let bestScore = 0;\n        let bestMovie: { Title: string; Url: string } | undefined;\n\n        for (const movie of movies) {\n            let score: number = 0;\n            let strOutput = \"\"\n            // TITLE\n            score += this.scoreStringMatch(2, movie.Title, opts);\n            strOutput += `Title: ${movie.Title} VS ${opts}, Current Score: ${score}\\n`;\n\n            console.log(`Movie: ${movie.Title}\\n${strOutput}Total Score: ${score}\\n--------------------`);\n\n            if (score \u003e bestScore) {\n                bestScore = score;\n                bestMovie = movie;\n            }\n        }\n\n        if (bestMovie) {\n            console.log(\"Best movie found:\", bestMovie);\n            return bestMovie;\n        }\n        return undefined;\n    }\n\n    private async findSubtitles(html, serverUrl: string, unpacked?: string): Promise\u003cVideoSubtitle[]\u003e {\n        let subtitles: VideoSubtitle[] = [];\n        const subtitleRegex = /\u003ctrack\\s+[^\u003e]*src=[\"']([^\"']+\\.vtt(?:\\?[^\"']*)?)[\"'][^\u003e]*\u003e/gi;\n        let trackMatches = html.matchAll(subtitleRegex);\n\n        for (const match of trackMatches) {\n            const src = match[1];\n            const fullTag = match[0];\n\n            let url = src.startsWith(\"http\") ? src : `${serverUrl.split(\"/\").slice(0, 3).join(\"/\")}${src}`;\n\n            // Attempt to extract language info\n            const langMatch = fullTag.match(/(?:label|srclang)=[\"']?([a-zA-Z\\-]{2,})[\"']?/i);\n            const langCode = langMatch?.[1]?.toLowerCase() || \"\";\n\n            const language = languageMap[langCode] || langCode || \"Unknown\";\n\n            const isDefault = /default/i.test(fullTag);\n\n            subtitles.push({\n                id: `sub-${subtitles.length}`,\n                url,\n                language,\n                isDefault,\n            });\n        }\n\n        // Fallback: look for direct .vtt URLs (if \u003ctrack\u003e not used)\n        if (subtitles.length === 0) {\n            const rawSubtitleRegex = /https?:\\/\\/[^\\s'\"]+\\.vtt(?:\\?[^'\"\\s]*)?/g;\n            let subtitleMatches = html.match(rawSubtitleRegex) || unpacked?.match(rawSubtitleRegex) || [];\n\n            if (subtitleMatches.length \u003e 0) {\n                if (!subtitleMatches.some(url =\u003e url.startsWith(\"http\"))) {\n                    const baseUrl = serverUrl.split(\"/\").slice(0, 3).join(\"/\");\n                    subtitleMatches = subtitleMatches.map(url =\u003e `${baseUrl}${url}`);\n                }\n\n                subtitles = subtitleMatches.map((url, idx) =\u003e {\n                    const filename = url.split(\"/\").pop() || \"\";\n                    const codeMatch = filename.match(/([a-z]{2,3})(?=\\.vtt)/i);\n                    const langCode = codeMatch?.[1]?.toLowerCase() || \"\";\n                    const language = languageMap[langCode] || langCode || \"Unknown\";\n\n                    return {\n                        id: `sub-${idx}`,\n                        url,\n                        language,\n                        isDefault: idx === 0,\n                    };\n                });\n            }\n        }\n\n        if (subtitles) {\n            console.log(\"Subtitles found:\", subtitles);\n        }\n\n        return subtitles;\n    }\n\n    private async findMediaUrls(type: VideoSourceType, html, serverUrl: string, resolutionMatch?: RegExpMatchArray, unpacked?: string): Promise\u003cVideoSource[] | VideoSource | undefined\u003e {\n\n        const regex = new RegExp('https?:\\\\/\\\\/[^\\'\"]+\\\\.' + type + '(?:\\\\?[^\\\\s\\'\"]*)?(?:#[^\\\\s\\'\"]*)?', 'g');\n\n        let VideoMatch = html.match(regex)\n            || unpacked?.match(regex)\n            || html.match(new RegExp(`\"([^\"]+\\\\.${type})\"`, \"g\"))\n            || unpacked?.match(new RegExp(`\"([^\"]+\\\\.${type})\"`, \"g\"));\n\n        if (VideoMatch) {\n            if (!VideoMatch.some(url =\u003e url.startsWith(\"http\"))) {\n                const serverurldomain = serverUrl.split(\"/\").slice(0, 3).join(\"/\");\n                VideoMatch = VideoMatch.map(url =\u003e `${serverurldomain}${url}`.replaceAll(`\"`, \"\"));\n            }\n\n            if (VideoMatch.length \u003e 1) {\n                // If found multiple, euhm we are cooked... idk yet let me think of it lmao\n                console.warn(`Found multiple ${type} URLs:`, VideoMatch);\n                // for now take the first one idk\n                VideoMatch.forEach(element =\u003e {\n                    if (VideoMatch[0] !== element) {\n                        VideoMatch.pop();\n                    }\n                });\n            }\n            else {\n                console.log(`Found ${type} URL:`, VideoMatch[0]);\n            }\n\n            if (VideoMatch[0].includes(`master.${type}`)) {\n                // fetch the match to see if the m3u8 is main or extension\n                // get the referer of the ServerUrl\n                const ref = serverUrl.split(\"/\").slice(0, 3).join(\"/\");\n                const req = await fetch(`${this.SEANIME_API}${encodeURIComponent(VideoMatch[0])}`);\n                let reqHtml = await req.text();\n                reqHtml = decodeURIComponent(reqHtml);\n                let qual = \"\";\n                let url = \"\";\n                const videos: VideoSource[] = [];\n                if (reqHtml.includes(\"#EXTM3U\")) {\n                    reqHtml.split(\"\\n\").forEach(line =\u003e {\n                        if (line.startsWith(\"#EXT-X-STREAM-INF\")) {\n                            qual = line.split(\"RESOLUTION=\")[1]?.split(\",\")[0] || \"unknown\";\n                            const height = parseInt(qual.split(\"x\")[1]) || 0;\n\n                            if (height \u003e= 1080) {\n                                qual = \"1080p\";\n                            } else if (height \u003e= 720) {\n                                qual = \"720p\";\n                            } else if (height \u003e= 480) {\n                                qual = \"480p\";\n                            } else if (height \u003e= 360) {\n                                qual = \"360p\";\n                            } else {\n                                qual = \"unknown\";\n                            }\n                        }\n                        else if (line.startsWith(\"/api/v1/proxy?url=http\")) {\n                            url = line.replace(\"/api/v1/proxy?url=\", \"\");\n                        }\n\n                        if (url \u0026\u0026 qual) {\n                            videos.push({\n                                url: url,\n                                type: type,\n                                quality: `${this._Server} - ${qual}`,\n                                subtitles: []\n                            })\n                            url = \"\";\n                            qual = \"\";\n                        }\n                    });\n                }\n\n                if (videos.length \u003e 0) {\n                    for (const video of videos) {\n                        video.subtitles = await this.findSubtitles(html, serverUrl, unpacked);\n                    }\n                    return videos.sort((a, b) =\u003e {\n                        const resolutionOrder = [\"1080p\", \"720p\", \"480p\", \"360p\", \"unknown\"];\n                        const aIndex = resolutionOrder.indexOf(a.quality.split(\" \")[2]);\n                        const bIndex = resolutionOrder.indexOf(b.quality.split(\" \")[2]);\n                        return aIndex - bIndex;\n                    });\n                }\n                else {\n                    console.warn(`${type} master is not in a correct format`)\n                }\n            }\n            else {\n                console.warn(`No ${type} master URL found`);\n            }\n\n\n            // oppai stream quality exception\n            const regex = /\\/(\\d{3,4})\\//;\n            const resolutionMatch = VideoMatch[0].match(regex);\n\n            return {\n                url: VideoMatch[0],\n                quality: resolutionMatch ? resolutionMatch[1] : `${this._Server} - unknown`,\n                type: type,\n                subtitles: await this.findSubtitles(html, serverUrl, unpacked)\n            };\n\n        }\n\n        return undefined;\n    }\n\n    private async HandleServerUrl(serverUrl: string): Promise\u003cVideoSource[] | VideoSource\u003e {\n\n        const req = await fetch(`${this.SEANIME_API}${encodeURIComponent(serverUrl)}`);\n        if (!req.ok) {\n            console.log(\"Failed to fetch server URL:\", serverUrl, \"Status:\", req.status);\n            return [];\n        }\n\n        const html = await req.text();\n\n        // special case Dean Edwardsâ€™ Packer\n        // .match(/eval\\(function\\(p,a,c,k,e,d\\)(.*?)\\)\\)/s);\n        function unpack(p, a, c, k) { while (c--) if (k[c]) p = p.replace(new RegExp('\\\\b' + c.toString(a) + '\\\\b', 'g'), k[c]); return p }\n        // regex is weird here so i did it manually\n        function extractScripts(str: string): string[] {\n            const results: string[] = [];\n            const openTag = \"\u003cscript type='text/javascript'\u003e\";\n            const closeTag = \"\u003c/script\u003e\";\n\n            let pos = 0;\n\n            while (pos \u003c str.length) {\n                const start = str.indexOf(openTag, pos);\n                if (start === -1) break;\n                const end = str.indexOf(closeTag, start);\n                if (end === -1) break;\n                const content = str.substring(start + openTag.length, end);\n                results.push(content);\n                pos = end + closeTag.length;\n            }\n\n            return results;\n        }\n\n        let unpacked;\n        const scriptContents = extractScripts(html);\n        for (const c of scriptContents) {\n            let c2 = c;\n            // change c for each 200 char put \\n (it too long)\n            for (let j = 0; j \u003c c.length; j += 900) {\n                c2 = c2.substring(0, j) + \"\\n\" + c2.substring(j);\n            }\n            if (c.includes(\"eval(function(p,a,c,k,e,d)\")) {\n\n                console.log(\"Unpacked has been found.\");\n                const fullRegex = /eval\\(function\\([^)]*\\)\\{[\\s\\S]*?\\}\\(\\s*'([\\s\\S]*?)'\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*'([\\s\\S]*?)'\\.split\\('\\|'\\)/;\n                const match = c2.match(fullRegex);\n\n                if (match) {\n                    const packed = match[1];\n                    const base = parseInt(match[2], 10);\n                    const count = parseInt(match[3], 10);\n                    const dict = match[4].split('|');\n\n                    unpacked = unpack(packed, base, count, dict);\n                    // decode unicode example \\uXXXX\n                    unpacked = unpacked.replace(/\\\\u([\\d\\w]{4})/gi, (_, grp) =\u003e String.fromCharCode(parseInt(grp, 16)))\n                        .replace(/%3C/g, '\u003c').replace(/%3E/g, '\u003e')\n                        .replace(/%3F/g, '?')\n                        .replace(/%3A/g, ':')\n                        .replace(/%2C/g, ',')\n                        .replace(/%2F/g, '/')\n                        .replace(/%2B/g, '+')\n                        .replace(/%20/g, ' ')\n                        .replace(/%21/g, '!')\n                        .replace(/%22/g, '\"')\n                        .replace(/%27/g, \"'\")\n                        .replace(/%28/g, '(').replace(/%29/g, ')')\n                        .replace(/%3B/g, ';');\n                }\n            }\n        }\n\n        // exception for oppai-stream\n        // const resolutionRegex = /(?:^|[^a-zA-Z0-9])(\\d{3,4})p(?=[^a-zA-Z0-9]|$)/;\n        // const resolutionMatch =\n        //     html.match(resolutionRegex) ||\n        //     unpacked?.match(resolutionRegex);\n\n        // if (resolutionMatch) {\n        //     const resolution = resolutionMatch[1];\n        //     console.log(\"Found resolution:\", resolution);\n        // }\n\n        // look for .m3u8\n        const m3u8Videos = await this.findMediaUrls(\"m3u8\", html, serverUrl, undefined, unpacked);\n        if (m3u8Videos !== undefined) {\n            console.log(\"Found m3u8: \", m3u8Videos);\n            return m3u8Videos;\n        }\n\n        // look for .mp4 do the same as .m3u8\n        const mp4Videos = await this.findMediaUrls(\"mp4\", html, serverUrl, undefined, unpacked);\n        if (mp4Videos !== undefined) {\n            console.log(\"Found mp4: \", mp4Videos);\n            return mp4Videos;\n        }\n\n        console.warn(\"No m3u8 or mp4 URLs found in the server URL:\", serverUrl, \". Make sure this is true.\");\n        return [];\n    }\n\n    //#endregion\n\n    //#region main\n\n    async search(opts: SearchOptions): Promise\u003cSearchResult[]\u003e {\n        let tempquery = opts.query;\n\n        while (tempquery !== \"\") {\n            console.log(`Searching for query: \"${tempquery}\".`);\n            const html = await fetch(this.SEARCH_URL + encodeURIComponent(tempquery)).then(res =\u003e res.text());\n            const $ = await LoadDoc(html);\n            const movies = $(\"div.in-grid.episode-shown\")\n            if (movies.length() \u003c= 0) {\n                tempquery = tempquery.split(/[\\s:']+/).slice(0, -1).join(\" \");\n                continue;\n            }\n\n            const movieList: { Title: string; Url: string }[] = [];\n            movies.each((_, el) =\u003e {\n                const title = el.find(\".title-ep\").text().trim();\n                const url = el.find(\"a\").attr(\"href\")?.replace(\"\u0026for=search\", \"\");\n                if (title \u0026\u0026 url) {\n                    movieList.push({ Title: title, Url: url });\n                }\n            });\n            const bestMovie = this.findBestTitle(movieList, opts.query);\n            if (!bestMovie) {\n                return [];\n            }\n\n            return \u003cSearchResult[]\u003e[{\n                id: bestMovie.Url,\n                title: bestMovie.Title,\n                url: bestMovie.Url,\n                subOrDub: opts.dub ? \"dub\" : \"sub\",\n            }];\n        }\n\n        return [];\n    }\n\n    async findEpisodes(id: string): Promise\u003cEpisodeDetails[]\u003e {\n        if(id === \"\" || !id) {\n            return [];\n        }\n        const MainHtml = await fetch(id).then(res =\u003e res.text());\n        const $ = await LoadDoc(MainHtml);\n        const episodeDetails: EpisodeDetails[] = [];\n        // map all episode URLs\n        const eps = $(\"div.other-episodes.more-same-eps div.in-grid.episode-shown\");\n\n        eps.each((_, el) =\u003e {\n            const id = el.attr(\"idgt\");\n            if (id) {\n                const url = el.find(\"a\").attr(\"href\")?.replace(\"\u0026for=episode-more\", \"\") || \"\";\n                episodeDetails.push({\n                    id: url,\n                    number: parseInt(el.find(\"h5 .ep\").text(), 10),\n                    title: el.find(\"h5 .title\").text(),\n                    url: url,\n                });\n            }\n        });\n\n        return episodeDetails;\n    }\n\n    async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise\u003cEpisodeServer\u003e {\n        this._Server = _server;\n        const servers = episode.id.split(\",\");\n        // get the right url server\n        const serverUrl = servers.find(server =\u003e server.includes(_server));\n        const videoSources = \u003cVideoSource[]\u003e[];\n        if (serverUrl \u0026\u0026 _server !== \"\") {\n            console.log(`Handling server URL: ${serverUrl}`);\n            const result = await this.HandleServerUrl(serverUrl);\n            if (Array.isArray(result)) {\n                videoSources.push(...result);\n            } else {\n                videoSources.push(result);\n            }\n        }\n        else {\n            console.log(`Server not found: ${_server}\\n Try with these servers:\\n- ${servers.map(url =\u003e {\n                const parts = url.split(\"/\");\n                const partsServerName = parts[2] ? parts[2].split(\".\") : [];\n                const serverName = partsServerName.length \u003e= 3 ? partsServerName[1] : partsServerName[0];\n                return serverName;\n            }).join(\"\\n- \")}`);\n            if (servers.includes(_server)) {\n                return \u003cEpisodeServer\u003e{\n                    headers: {},\n                    server: _server + \" (video not found)\",\n                    videoSources: \u003cVideoSource[]\u003e[\n                        {\n                            // dummy video source\n                            url: \"https://devstreaming-cdn.apple.com/videos/streaming/examples/img_bipbop_adv_example_fmp4/master.m3u8\",\n                            type: \"m3u8\",\n                            quality: \"video not found\",\n                            subtitles: []\n                        }\n                    ]\n\n                };\n            } else {\n                return \u003cEpisodeServer\u003e{\n                    headers: {},\n                    server: \"\",\n                    videoSources: []\n                };\n            }\n\n        }\n\n        if (videoSources.length \u003e 0) {\n            const ref = serverUrl.split(\"/\").slice(0, 3).join(\"/\");\n            return {\n                headers: {\n                    referer: ref\n                },\n                server: _server,\n                videoSources: videoSources\n            };\n        }\n        else {\n            console.log(`No video sources found for server: ${_server}`);\n            return \u003cEpisodeServer\u003e{\n                headers: {},\n                server: _server + \" (video not found)\",\n                videoSources: \u003cVideoSource[]\u003e[\n                    {\n                        url: \"https://devstreaming-cdn.apple.com/videos/streaming/examples/img_bipbop_adv_example_fmp4/master.m3u8\",\n                        type: \"m3u8\",\n                        quality: \"video not found\",\n                        subtitles: []\n                    }\n                ]\n\n            };\n        }\n    }\n\n    //#endregion\n}"
}
