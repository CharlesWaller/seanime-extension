{
    "id": "anime-sama-online-streaming",
    "name": "Anime Sama",
    "version": "1.0.0",
    "manifestURI": "https://raw.githubusercontent.com/TropicalFrog3/seanime-extension/refs/heads/main/online-streaming/anime-sama/manifest.json",
    "language": "typescript",
    "type": "onlinestream-provider",
    "description": "Anime Sama est une extension Seanime en fran√ßais qui permet de regarder des anime dans le catalogue du site anime-sama.com.",
    "author": "TropicalFrog3",
    "icon": "https://raw.githubusercontent.com/TropicalFrog3/seanime-extension/refs/heads/main/online-streaming/anime-sama/favicon.png",
    "website": "",
    "lang": "fr",
    "payload": "/// \u003creference path=\"../_external/.onlinestream-provider.d.ts\" /\u003e\n/// \u003creference path=\"../_external/core.d.ts\" /\u003e\n\n//#region console\n\nconst DevMode = false;\nconst originalConsoleLog = console.log;\nconsole.log = function (...args: any[]) {\n    if (DevMode) {\n        originalConsoleLog.apply(console, args);\n    }\n};\n\n//#endregion\n\n//#region types\n\nenum ScoreWeight {\n    // query\n    Title = 3.6,\n    // dub\n    Language = 2.5,\n    // media.format\n    SeasonOrFilm = 2.1,\n    // year\n    ReleaseDate = 1,\n    // media.episodeCount\n    EpisodeCount = 1,\n\n    MaxScore = 10,\n}\n\n//#endregion\n\nclass Provider {\n\n    //#region variables\n\n    readonly SEARCH_URL_2 = \"https://anime-sama.fr/template-php/defaut/fetch.php\";\n    // idk yet how to get the api url of seanime, so i just hardcoded it\n    readonly SEANIME_API = \"http://127.0.0.1:43211/api/v1/proxy?url=\";\n\n    _Server = \"\";\n\n    //#endregion\n\n    //#region methods\n\n    getSettings(): Settings {\n        return {\n            episodeServers: [\n                \"vidmoly\", \"movearnpre\",\"sibnet\",\"oneupload\",\"sendvid\",\n            ],\n            supportsDub: true,\n        }\n    }\n\n    //#endregion\n\n    //#region utility\n\n    private getWordVector(word: string): number[] {\n        // Dummy implementation: convert word to a vector of character codes\n        // I'll probably change it one in an other update\n        return Array.from(word).map(char =\u003e char.charCodeAt(0));\n    }\n\n    private cosineSimilarity(vec1: number[], vec2: number[]): number {\n        const dotProduct = vec1.reduce((sum, val, i) =\u003e sum + val * (vec2[i] || 0), 0);\n        const magnitude1 = Math.sqrt(vec1.reduce((sum, val) =\u003e sum + val * val, 0));\n        const magnitude2 = Math.sqrt(vec2.reduce((sum, val) =\u003e sum + val * val, 0));\n        return magnitude1 \u0026\u0026 magnitude2 ? dotProduct / (magnitude1 * magnitude2) : 0;\n    }\n\n    private getWordSimilarity(word1: string, words: string[]): number {\n        const word1Vector = this.getWordVector(word1);\n        let maxSimilarity = 0;\n\n        for (const word2 of words) {\n            const word2Vector = this.getWordVector(word2);\n            const similarity = this.cosineSimilarity(word1Vector, word2Vector);\n            maxSimilarity = Math.max(maxSimilarity, similarity);\n        }\n\n        return maxSimilarity;\n    }\n\n    private scoreStringMatch(weight: number, text: string | undefined, query: string | undefined): number {\n        // Simple scoring mechanism: \n        // +2 point if it the same\n        // split into words: \n        //      TOTAL: +2/nb words\n        //          -0% point to total per exact word match (case insensitive)\n        //          -5% point to total if word query and word text have 80% similarity\n        //          -10% point to total if word query and word text have 50% similarity\n        //          -15% point to total if word query and word text have 30% similarity\n        //          -20% point to total if word query and word text have 10% similarity\n        //          -100% point to total if word query and word text have 0% similarity\n        // Higher score means better match\n        // below 0 means no match, Warn all my test were correct, but i didn't test them all\n\n        if (!text || !query) return 0;\n\n        text = text.toLowerCase();\n        query = query.toLowerCase();\n\n        let score = 0;\n        if (text === query)\n            return ScoreWeight.MaxScore * weight;\n\n        const textWords = text.split(\" \");\n        const queryWords = query.split(\" \");\n\n        for (const word of queryWords) {\n            if (textWords.includes(word)) {\n                score += ScoreWeight.MaxScore / textWords.length;\n            }\n            else {\n                const similarity = this.getWordSimilarity(word, textWords);\n                score -= similarity * ScoreWeight.MaxScore / textWords.length;\n            }\n        }\n\n        return score * weight;\n    }\n\n    private findBestTitle(movies: { Title: string; Url: string }[], opts: string): { Title: string; Url: string } | undefined {\n        let bestScore = 0;\n        let bestMovie: { Title: string; Url: string } | undefined;\n\n        for (const movie of movies) {\n            let score: number = 0;\n            let strOutput = \"\"\n            // TITLE\n            score += this.scoreStringMatch(2, movie.Title, opts);\n            strOutput += `Title: ${movie.Title} VS ${opts}, Current Score: ${score}\\n`;\n\n            console.log(`Movie: ${movie.Title}\\n${strOutput}Total Score: ${score}\\n--------------------`);\n\n            if (score \u003e bestScore) {\n                bestScore = score;\n                bestMovie = movie;\n            }\n        }\n\n        if (bestMovie) {\n            console.log(\"Best movie found:\", bestMovie);\n            return bestMovie;\n        }\n        return undefined;\n    }\n\n    private async findMediaUrls(type: VideoSourceType, html, serverUrl: string, resolutionMatch?: RegExpMatchArray, unpacked?: string): Promise\u003cVideoSource[] | VideoSource | undefined\u003e {\n\n        const regex = new RegExp('https?:\\\\/\\\\/[^\\'\"]+\\\\.' + type + '(?:\\\\?[^\\\\s\\'\"]*)?(?:#[^\\\\s\\'\"]*)?', 'g');\n\n        let VideoMatch = html.match(regex)\n            || unpacked?.match(regex)\n            || html.match(new RegExp(`\"([^\"]+\\\\.${type})\"`, \"g\"))\n            || unpacked?.match(new RegExp(`\"([^\"]+\\\\.${type})\"`, \"g\"));\n\n        if (VideoMatch) {\n            if (!VideoMatch.some(url =\u003e url.startsWith(\"http\"))) {\n                const serverurldomain = serverUrl.split(\"/\").slice(0, 3).join(\"/\");\n                VideoMatch = VideoMatch.map(url =\u003e `${serverurldomain}${url}`.replaceAll(`\"`, \"\"));\n            }\n\n            if (VideoMatch.length \u003e 1) {\n                // If found multiple, euhm we are cooked... idk yet let me think of it lmao\n                console.warn(\"Found multiple m3u8 URLs:\", VideoMatch);\n                // for now take the first one idk\n                VideoMatch.forEach(element =\u003e {\n                    if (VideoMatch[0] !== element) {\n                        VideoMatch.pop();\n                    }\n                });\n            }\n            else {\n                console.log(\"Found m3u8 URL:\", VideoMatch[0]);\n            }\n\n            if (VideoMatch[0].includes(`master.${type}`)) {\n                // fetch the match to see if the m3u8 is main or extension\n                // get the referer of the ServerUrl\n                const ref = serverUrl.split(\"/\").slice(0, 3).join(\"/\");\n                const req = await fetch(`${this.SEANIME_API}${encodeURIComponent(VideoMatch[0])}`);\n                let reqHtml = await req.text();\n                reqHtml = decodeURIComponent(reqHtml);\n                let qual = \"\";\n                let url = \"\";\n                const videos: VideoSource[] = [];\n                if (reqHtml.includes(\"#EXTM3U\")) {\n                    reqHtml.split(\"\\n\").forEach(line =\u003e {\n                        if (line.startsWith(\"#EXT-X-STREAM-INF\")) {\n                            qual = line.split(\"RESOLUTION=\")[1]?.split(\",\")[0] || \"unknown\";\n                            const height = parseInt(qual.split(\"x\")[1]) || 0;\n\n                            if (height \u003e= 1080) {\n                                qual = \"1080p\";\n                            } else if (height \u003e= 720) {\n                                qual = \"720p\";\n                            } else if (height \u003e= 480) {\n                                qual = \"480p\";\n                            } else if (height \u003e= 360) {\n                                qual = \"360p\";\n                            } else {\n                                qual = \"unknown\";\n                            }\n                        }\n                        else if (line.startsWith(\"/api/v1/proxy?url=http\")) {\n                            url = line.replace(\"/api/v1/proxy?url=\", \"\");\n                        }\n\n                        if (url \u0026\u0026 qual) {\n                            videos.push({\n                                url: url,\n                                type: type,\n                                quality: `${this._Server} - ${qual}`,\n                                subtitles: []\n                            })\n                            url = \"\";\n                            qual = \"\";\n                        }\n                    });\n                }\n\n                if (videos.length \u003e 0) {\n                    return videos.sort((a, b) =\u003e {\n                        const resolutionOrder = [\"1080p\", \"720p\", \"480p\", \"360p\", \"unknown\"];\n                        const aIndex = resolutionOrder.indexOf(a.quality.split(\" \")[2]);\n                        const bIndex = resolutionOrder.indexOf(b.quality.split(\" \")[2]);\n                        return aIndex - bIndex;\n                    });\n                }\n                else {\n                    console.warn(\"m3u8 master is not in a correct format\")\n                }\n            }\n            else {\n                console.warn(\"No master m3u8 URL found\");\n            }\n\n            return {\n                url: VideoMatch[0],\n                quality: resolutionMatch ? resolutionMatch[1] : `${this._Server} - unknown`,\n                type: type,\n                subtitles: []\n            };\n        }\n\n        return undefined;\n    }\n\n    private async HandleServerUrl(serverUrl: string): Promise\u003cVideoSource[] | VideoSource\u003e {\n\n        const req = await fetch(`${this.SEANIME_API}${encodeURIComponent(serverUrl)}`);\n        if (!req.ok) {\n            console.log(\"Failed to fetch server URL:\", serverUrl, \"Status:\", req.status);\n            return [];\n        }\n\n        const html = await req.text();\n\n        // special case Dean Edwards‚Äô Packer\n        // .match(/eval\\(function\\(p,a,c,k,e,d\\)(.*?)\\)\\)/s);\n        function unpack(p, a, c, k) { while (c--) if (k[c]) p = p.replace(new RegExp('\\\\b' + c.toString(a) + '\\\\b', 'g'), k[c]); return p }\n        // regex is weird here so i did it manually\n        function extractScripts(str: string): string[] {\n            const results: string[] = [];\n            const openTag = \"\u003cscript type='text/javascript'\u003e\";\n            const closeTag = \"\u003c/script\u003e\";\n\n            let pos = 0;\n\n            while (pos \u003c str.length) {\n                const start = str.indexOf(openTag, pos);\n                if (start === -1) break;\n                const end = str.indexOf(closeTag, start);\n                if (end === -1) break;\n                const content = str.substring(start + openTag.length, end);\n                results.push(content);\n                pos = end + closeTag.length;\n            }\n\n            return results;\n        }\n\n        let unpacked;\n        const scriptContents = extractScripts(html);\n        for (const c of scriptContents) {\n            let c2 = c;\n            // change c for each 200 char put \\n (it too long)\n            for (let j = 0; j \u003c c.length; j += 900) {\n                c2 = c2.substring(0, j) + \"\\n\" + c2.substring(j);\n            }\n            if (c.includes(\"eval(function(p,a,c,k,e,d)\")) {\n\n                console.log(\"Unpacked has been found.\");\n                const fullRegex = /eval\\(function\\([^)]*\\)\\{[\\s\\S]*?\\}\\(\\s*'([\\s\\S]*?)'\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*'([\\s\\S]*?)'\\.split\\('\\|'\\)/;\n                const match = c2.match(fullRegex);\n\n                if (match) {\n                    const packed = match[1];\n                    const base = parseInt(match[2], 10);\n                    const count = parseInt(match[3], 10);\n                    const dict = match[4].split('|');\n\n                    unpacked = unpack(packed, base, count, dict);\n                    // decode unicode example \\uXXXX\n                    unpacked = unpacked.replace(/\\\\u([\\d\\w]{4})/gi, (_, grp) =\u003e String.fromCharCode(parseInt(grp, 16)))\n                        .replace(/%3C/g, '\u003c').replace(/%3E/g, '\u003e')\n                        .replace(/%3F/g, '?')\n                        .replace(/%3A/g, ':')\n                        .replace(/%2C/g, ',')\n                        .replace(/%2F/g, '/')\n                        .replace(/%2B/g, '+')\n                        .replace(/%20/g, ' ')\n                        .replace(/%21/g, '!')\n                        .replace(/%22/g, '\"')\n                        .replace(/%27/g, \"'\")\n                        .replace(/%28/g, '(').replace(/%29/g, ')')\n                        .replace(/%3B/g, ';');\n                }\n            }\n        }\n\n        // look for resolution: [4 to 3 numbers]p, have \" or [space] after p if its the [space] it must be between to [space]\n        // example: 1080p\" or 1080p\n        const resolutionMatch = html.match(/(\\d{3,4})p(?=[\" ])/) || unpacked?.match(/(\\d{3,4})p(?=[\" ])/);\n        if (resolutionMatch) {\n            const resolution = resolutionMatch[1];\n            console.log(\"Found resolution:\", resolution);\n        }\n\n        // look for .m3u8\n        const m3u8Videos = await this.findMediaUrls(\"m3u8\", html, serverUrl, resolutionMatch, unpacked);\n        if (m3u8Videos !== undefined) {\n            console.log(\"Found m3u8: \", m3u8Videos);\n            return m3u8Videos;\n        }\n\n        // look for .mp4 do the same as .m3u8\n        const mp4Videos = await this.findMediaUrls(\"mp4\", html, serverUrl, resolutionMatch, unpacked);\n        if (mp4Videos !== undefined) {\n            console.log(\"Found mp4: \", mp4Videos);\n            return mp4Videos;\n        }\n\n        console.warn(\"No m3u8 or mp4 URLs found in the server URL:\", serverUrl, \". Make sure this is true.\");\n        return [];\n    }\n\n    //#endregion\n\n    //#region main\n\n    async search(opts: SearchOptions): Promise\u003cSearchResult[]\u003e {\n        let tempquery = opts.query;\n\n        const queryEnglish = opts.media.englishTitle || opts.query;\n        const seasonMatch = queryEnglish.toLowerCase().match(/season\\s*(\\d+)/i);\n        const seasonMatch2 = queryEnglish.toLowerCase().match(/(\\d+)/);\n\n        let seasonNumberOpts;\n        if (seasonMatch) {\n            seasonNumberOpts = parseInt(seasonMatch[1], 10);\n            console.log(\"Found season number:\", seasonNumberOpts);\n        }\n\n        let partNumberOpts;\n        const partMatch = queryEnglish.toLowerCase().match(/part\\s*(\\d+)/i);\n        if (partMatch) {\n            partNumberOpts = parseInt(partMatch[1], 10);\n            console.log(\"Found part number:\", partNumberOpts);\n        }\n        else {\n            seasonNumberOpts = seasonMatch2 ? parseInt(seasonMatch2[1], 10) : opts.media.format === \"TV\" ? 1 : -1;\n        }\n\n        while (tempquery !== \"\") {\n            console.log(`Searching for query: \"${tempquery}\".`);\n            const body = new URLSearchParams({ query: tempquery });\n            const html = await fetch(\n                this.SEARCH_URL_2,\n                {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/x-www-form-urlencoded\",\n                    },\n                    body\n                }\n            ).then(async res =\u003e await res.text());\n            const $ = await LoadDoc(html);\n            const movies = $(\".flex.rounded.border-t-2.border-sky-600.hover\\\\:bg-gray-700.hover\\\\:text-sky-500\");\n            if (movies.length() \u003c= 0) {\n                tempquery = tempquery.split(/[\\s:']+/).slice(0, -1).join(\" \");\n                continue;\n            }\n\n            // if movies has more than 1 el.find(\"h3\").text();\n            let movieUrl: string;\n            if (movies.map((i, el) =\u003e el.find(\"h3\")).length \u003e 1) {\n                // TODO: search for the best\n                console.warn(\"Found multiple movies, searching for the best match...\");\n                movieUrl = movies.attr(\"href\") || \"\";\n            }\n            else {\n                movieUrl = movies.attr(\"href\") || \"\";\n            }\n\n            console.log(movieUrl)\n\n            const html2 = await fetch(movieUrl).then(res =\u003e res.text());\n            let animesJson: { Title: string; Url: string }[] = [];\n            const Regex = /panneauAnime\\(\"([^\"]+)\", \"([^\"]+)\"\\);/g;\n            let match;\n            while (match = Regex.exec(await LoadDoc(html2)(\".flex.flex-wrap.overflow-y-hidden.justify-start.bg-slate-900.bg-opacity-70.rounded.mt-2.h-auto\").text())) {\n                const animeTitle = match[1];\n                const animeUrl = match[2];\n\n                if (animeTitle === \"nom\" || animeUrl === \"url\") {\n                    continue;\n                }\n                if (opts.media.format !== \"Special\" \u0026\u0026 animeUrl.includes(\"oav/\") === true) {\n                    continue;\n                }\n                if (opts.media.format !== \"MOVIE\" \u0026\u0026 animeUrl.includes(\"film/\") === true) {\n                    continue;\n                }\n                if (animeTitle.includes(\"Kai -\") === true) {\n                    continue;\n                }\n                if (animeTitle.includes(\"Sans Fillers\") === true) {\n                    continue;\n                }\n                const regex = partNumberOpts ? new RegExp(`saison${seasonNumberOpts || 1}-${partNumberOpts}(?!\\\\d)`) : new RegExp(`saison${seasonNumberOpts}(?!\\\\d)`);\n                if (seasonNumberOpts !== -1 \u0026\u0026 !animeUrl.match(regex)) {\n                    continue;\n                }\n                if ((opts.media.format !== \"Special\" \u0026\u0026 opts.media.format !== \"TV\" \u0026\u0026 opts.media.format !== \"ONA\" \u0026\u0026 opts.media.format !== \"OVA\") \u0026\u0026 animeUrl.includes(\"saison\") === true) {\n                    continue;\n                }\n                animesJson.push({\n                    Title: animeTitle,\n                    Url: animeUrl\n                });\n            }\n\n            let BestAnimeTitle = animesJson.length \u003e 1 ? this.findBestTitle(animesJson, opts.media.englishTitle || opts.query) : animesJson[0];\n            if (!BestAnimeTitle) {\n                BestAnimeTitle = animesJson.find(anime =\u003e anime.Title.includes(\"Saison\"));\n            }\n\n            if (BestAnimeTitle === undefined) {\n                return [];\n            }\n\n            const finalUrl = opts.dub ? movieUrl + \"/\" + BestAnimeTitle.Url.replace(\"/vostfr\", \"/vf\") : movieUrl + \"/\" + BestAnimeTitle.Url;\n            if ((await fetch(finalUrl)).status !== 200 \u0026\u0026 (await fetch(finalUrl + \"1\")).status !== 200) {\n                console.log(`Failed to fetch ${opts.dub ? \"dub\" : \"sub\"} version of ${BestAnimeTitle.Title}`);\n                return [];\n            }\n\n            return \u003cSearchResult[]\u003e[{\n                id: finalUrl,\n                title: BestAnimeTitle.Title,\n                url: finalUrl,\n                subOrDub: opts.dub ? \"dub\" : \"sub\",\n            }];\n        }\n\n        return [];\n    }\n\n    async findEpisodes(id: string): Promise\u003cEpisodeDetails[]\u003e {\n\n        const $ = await fetch(id).then(res =\u003e res.text()).then(LoadDoc);\n        // find \u003cscript type=\"text/javascript\" src='episodes.js?filever={numbers}'defer\u003e\u003c/script\u003e\n        const fileverScript = $(\"script[src*='episodes.js?filever']\");\n        const filever = fileverScript.attr(\"src\");\n        const episodesText = await fetch(`${id}/${filever}`).then(res =\u003e res.text());\n        const episodeDetails: EpisodeDetails[] = [];\n        let ServerToAdd: string[] = [];\n        // MAX LECTEUR = 8 \n        // source: https://anime-sama.fr/js/contenu/script_videos.js?filever={ep #, ex: 14844}, line 39\n        const servers = [\"eps1\", \"eps2\", \"eps3\", \"eps4\", \"eps5\", \"eps6\", \"eps7\", \"eps8\"];\n\n        function replaceVidmoly(url) {\n            return url.replace(/vidmoly\\.to/g, 'vidmoly.net');\n        }\n\n        servers.forEach(server =\u003e {\n            const regex = new RegExp(`var\\\\s+${server}\\\\s*=\\\\s*\\\\[([\\\\s\\\\S]*?)\\\\];`, 'm');\n            const match = regex.exec(episodesText);\n            if (match) {\n                const urls = match[1].split(\",\").map(url =\u003e url.trim().replace(/['\"]/g, \"\"));\n                urls.forEach((url, index) =\u003e {\n                    if(url === \"\")\n                    {\n                        return;\n                    }\n                    if (url.includes(\"vidmoly.to\")) {\n                        url = replaceVidmoly(url);\n                    }\n                    episodeDetails.push({\n                        id: url,\n                        url: id,\n                        number: index + 1\n                    });\n                    // DEV CHECK TO FIND MISSING SERVERS\n                    if (DevMode) {\n                        for (const element of url.trim().replace(/,$/, \"\").split(\",\")) {\n                            // get the server name of the element\n                            const parts = element.split(\"/\");\n\n                            const PartsServerName = parts[2] ? parts[2].split(\".\") : [];\n                            const serverName = PartsServerName.length \u003e= 3 ? PartsServerName[1] : PartsServerName[0];\n                            // check if servername is in the list of the episode servers\n                            if (serverName !== undefined \u0026\u0026 !this.getSettings().episodeServers.includes(serverName) \u0026\u0026 !ServerToAdd.includes(serverName)) {\n                                ServerToAdd.push(serverName);\n                            }\n                        }\n                    }\n                });\n            }\n        });\n\n        if (ServerToAdd.length \u003e 0) {\n            console.warn(`Need to add server: \"${ServerToAdd.join(`\",\"`)}\"`);\n            this.getSettings().episodeServers.push(...ServerToAdd);\n        }\n\n        const mergedEpisodes = episodeDetails.reduce((acc, curr) =\u003e {\n            const existing = acc.find(ep =\u003e ep.number === curr.number);\n            if (existing) {\n            existing.id += `,${curr.id}`;\n            } else {\n            acc.push(curr);\n            }\n            return acc;\n        }, \u003cEpisodeDetails[]\u003e[]);\n\n        return mergedEpisodes;\n    }\n\n    async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise\u003cEpisodeServer\u003e {\n        // TODO: FIX vvide0 (its dood stream servers): 171018\n        this._Server = _server;\n        const servers = episode.id.split(\",\");\n        // get the right url server\n        const serverUrl = servers.find(server =\u003e server.includes(_server));\n        const videoSources = \u003cVideoSource[]\u003e[];\n        if (serverUrl \u0026\u0026 _server !== \"\") {\n            console.log(`Handling server URL: ${serverUrl}`);\n            const result = await this.HandleServerUrl(serverUrl);\n            if (Array.isArray(result)) {\n                videoSources.push(...result);\n            } else {\n                videoSources.push(result);\n            }\n        }\n        else {\n            console.log(`Server not found: ${_server}\\n Try with these servers:\\n- ${servers.map(url =\u003e {\n                const parts = url.split(\"/\");\n                const partsServerName = parts[2] ? parts[2].split(\".\") : [];\n                const serverName = partsServerName.length \u003e= 3 ? partsServerName[1] : partsServerName[0];\n                return serverName;\n            }).join(\"\\n- \")}`);\n            if (servers.includes(_server)) {\n                return \u003cEpisodeServer\u003e{\n                    headers: {},\n                    server: _server + \" (video not found)\",\n                    videoSources: \u003cVideoSource[]\u003e[\n                        {\n                            // dummy video source\n                            url: \"https://devstreaming-cdn.apple.com/videos/streaming/examples/img_bipbop_adv_example_fmp4/master.m3u8\",\n                            type: \"m3u8\",\n                            quality: \"video not found\",\n                            subtitles: []\n                        }\n                    ]\n\n                };\n            } else {\n                return \u003cEpisodeServer\u003e{\n                    headers: {},\n                    server: \"\",\n                    videoSources: []\n                };\n            }\n\n        }\n\n        if (videoSources.length \u003e 0) {\n            const ref = serverUrl.split(\"/\").slice(0, 3).join(\"/\");\n            return {\n                headers: {\n                    referer: ref\n                },\n                server: _server,\n                videoSources: videoSources\n            };\n        }\n        else {\n            console.log(`No video sources found for server: ${_server}`);\n            return \u003cEpisodeServer\u003e{\n                headers: {},\n                server: _server + \" (video not found)\",\n                videoSources: \u003cVideoSource[]\u003e[\n                    {\n                        url: \"https://devstreaming-cdn.apple.com/videos/streaming/examples/img_bipbop_adv_example_fmp4/master.m3u8\",\n                        type: \"m3u8\",\n                        quality: \"video not found\",\n                        subtitles: []\n                    }\n                ]\n\n            };\n        }\n    }\n\n    //#endregion\n}"
}