{
    "id": "hentaibros-provider",
    "name": "Hentaibros Anime Extension",
    "version": "1.0.0",
    "manifestURI": "",
    "language": "typescript",
    "type": "onlinestream-provider",
    "description": "Provides seamless integration with the Hentaibros catalog for online streaming within SeaAnime, enabling users to watch available titles directly from the platform.",
    "author": "chuck is dope",
    "icon": "",
    "website": "",
    "lang": "en",
    "payload": "/// <reference path=\".onlinestream-provider.d.ts\" />\n/// <reference path=\"./core.d.ts\" />\n\ntype EpisodeData = {\n    episode: number;\n    title: string;\n    session: string;\n};\n\nclass Provider {\n    api = \"https://hentaibros.net/\";\n\n    getSettings(): Settings {\n        return {\n            episodeServers: [\"kwik\"],\n            supportsDub: false,\n        };\n    }\n\n    async search(opts: SearchOptions): Promise<SearchResult[]> {\n        const query = typeof opts.query === \"string\" ? opts.query.trim() : \"\";\n        if (!query) return [];\n\n        try {\n            const res = await fetch(`${this.api}?s=${encodeURIComponent(query)}`, {\n                headers: {\n                    \"User-Agent\": \"Mozilla/5.0\",\n                    Cookie: \"__ddg1_=;__ddg2_=\"\n                }\n            });\n            if (!res.ok) return [];\n\n            const html = await res.text();\n            const $ = LoadDoc(html);\n\n            const el = $(\"article\").first();\n            if (!el || el.length === 0) return [];\n\n            const anchor = el.find(\"a\").first();\n            const title = anchor.find(\"header.entry-header span\").text().trim();\n            const url = anchor.attr(\"href\") || \"\";\n            if (!url || !title) return [];\n\n            const id = url.split(\"/\").filter(Boolean).pop() || \"\";\n            if (!id) return [];\n\n            return [\n                {\n                    subOrDub: \"sub\",\n                    id,\n                    title,\n                    url\n                }\n            ];\n        } catch (err) {\n            console.error(\"Search failed:\", err);\n            return [];\n        }\n    }\n\n    async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n        if (!id) throw new Error(\"Invalid anime id\");\n\n        const episodes: EpisodeDetails[] = [];\n        const res = await fetch(`${this.api}${id}/`, {\n            headers: {\n                \"User-Agent\": \"Mozilla/5.0\",\n                Cookie: \"__ddg1_=;__ddg2_=\"\n            }\n        });\n        if (!res.ok) throw new Error(\"Failed to load anime page\");\n\n        const html = await res.text();\n        const $ = LoadDoc(html);\n\n        const ogUrl = $(\"head > meta[property='og:url']\").attr(\"content\");\n        if (!ogUrl) throw new Error(\"Anime tempId not found\");\n\n        const tempId = ogUrl.split(\"/\").filter(Boolean).pop()!;\n        const apiRes = await fetch(`${this.api}/api?m=release&id=${tempId}&sort=episode_asc&page=1`, {\n            headers: { Cookie: \"__ddg1_=;__ddg2_=\" }\n        });\n        if (!apiRes.ok) throw new Error(\"Episode API request failed\");\n\n        const { last_page, data } = await apiRes.json() as { last_page: number; data: EpisodeData[]; };\n\n        const pushEpisodes = (items: EpisodeData[]) => {\n            for (const item of items) {\n                if (!item.session) continue;\n                episodes.push({\n                    id: `${item.session}$${id}`,\n                    number: parseInt(item.episode as any, 10) || 1,\n                    title: item.title || `Episode ${item.episode}`,\n                    url: `${this.api}${id}/`\n                });\n            }\n        };\n\n        pushEpisodes(data);\n\n        const pageNumbers = Array.from({ length: Math.max(0, last_page - 1) }, (_, i) => i + 2);\n        const pagePromises = pageNumbers.map(page =>\n            fetch(`${this.api}/api?m=release&id=${tempId}&sort=episode_asc&page=${page}`, {\n                headers: { Cookie: \"__ddg1_=;__ddg2_=\" }\n            }).then(r => r.json())\n        );\n\n        const results = await Promise.all(pagePromises);\n        results.forEach(page => pushEpisodes(page.data));\n\n        episodes.sort((a, b) => a.number - b.number);\n        return episodes.filter(ep => Number.isInteger(ep.number));\n    }\n\n    async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise<EpisodeServer> {\n        if (!episode?.id) throw new Error(\"Invalid episode ID\");\n\n        const [session, animeId] = episode.id.split(\"$\");\n        const url = `${this.api}/play/${animeId}/${session}`;\n\n        return {\n            server: \"kwik\",\n            headers: { Referer: this.api, \"User-Agent\": \"Mozilla/5.0\" },\n            videoSources: [\n                { url, type: \"m3u8\", quality: \"default\", subtitles: [] }\n            ]\n        };\n    }\n}"
}
