{
    "id": "anime-ultra-online-streaming",
    "name": "FR | Anime Ultra",
    "version": "1.0.0",
    "manifestURI": "https://raw.githubusercontent.com/TropicalFrog3/seanime-extension/refs/heads/main/online-streaming/anime-ultra/manifest.json",
    "language": "typescript",
    "type": "onlinestream-provider",
    "description": "Anime Ultra est une extension Seanime en français qui permet de regarder des anime dans le catalogue du site animesultra.org.",
    "author": "TropicalFrog3",
    "icon": "https://raw.githubusercontent.com/TropicalFrog3/seanime-extension/refs/heads/main/online-streaming/anime-ultra/favicon.png",
    "website": "",
    "lang": "fr",
    "payload": "/// \u003creference path=\"../_external/.onlinestream-provider.d.ts\" /\u003e\n/// \u003creference path=\"../_external/core.d.ts\" /\u003e\n\n//#region console\n\nconst DevMode = false;\nconst originalConsoleLog = console.log;\nconsole.log = function (...args: any[]) {\n    if (DevMode) {\n        originalConsoleLog.apply(console, args);\n    }\n};\n\n//#endregion\n\n//#region types\n\nenum ScoreWeight {\n    // query\n    Title = 3.6,\n    // dub\n    Language = 2.5,\n    // media.format\n    SeasonOrFilm = 2.1,\n    // year\n    ReleaseDate = 1,\n    // media.episodeCount\n    EpisodeCount = 1,\n\n    MaxScore = 10,\n}\n\nconst languageMap: Record\u003cstring, string\u003e = {\n    \"en\": \"English\",\n    \"eng\": \"English\",\n    \"es\": \"Spanish\",\n    \"spa\": \"Spanish\",\n    \"fr\": \"French\",\n    \"it\": \"Italian\",\n    \"ja\": \"Japanese\",\n    \"jp\": \"Japanese\",\n};\n\n//#endregion\n\nclass Provider {\n\n    //#region variables\n\n    readonly SEARCH_URL = \"https://animesultra.org/\";\n    readonly EPISODE_URL = \"https://animesultra.org/engine/ajax/full-story.php?\"\n    // idk yet how to get the api url of seanime, so i just hardcoded it\n    readonly SEANIME_API = \"http://127.0.0.1:43211/api/v1/proxy?url=\";\n\n    _Server = \"\";\n\n    //#endregion\n\n    //#region methods\n\n    getSettings(): Settings {\n        return {\n            // https://animesultra.org/templates/animeultra/js/movie.js LINE 97 - 347\n            episodeServers: [\n                \"vidmoly\", \"sendvid\", \"sibnet\", \"vidcdn\", \"mystream\", \"streamtape\", \"uqload\", \"cdnt2\", \"vip\", \"vid\", \"vidfast\", \"verystream\", \"rapids\",\n                \"cloudvideo\", \"mytv\", \"myvi\", \"uptostream\", \"gtv\", \"fembed\", \"hydrax\", \"gou\", \"cdnt\", \"rapidvideo\", \"namba\", \"kaztube\", \"tune\", \"netu\",\n                \"rutube\", \"dailymotion\", \"openload\", \"yandex\", \"ok\", \"vidspot\", \"cloudy\", \"google\", \"youtube\", \"moevideo\", \"mail\", \"mail2\"\n            ],\n            supportsDub: true,\n        }\n    }\n\n    //#endregion\n\n    //#region utility\n    private generateQueryVariants(query: string, maxVariants = 3): string[] {\n        const parts = query.trim().split(/[\\s:']+/);\n        const variants = [];\n\n        for (let i = parts.length; i \u003e= Math.max(parts.length - maxVariants + 1, 1); i--) {\n            variants.push(parts.slice(0, i).join(\" \"));\n        }\n\n        return [...new Set(variants)];\n    }\n\n    private getWordVector(word: string): number[] {\n        // Dummy implementation: convert word to a vector of character codes\n        // I'll probably change it one in an other update\n        return Array.from(word).map(char =\u003e char.charCodeAt(0));\n    }\n\n    private cosineSimilarity(vec1: number[], vec2: number[]): number {\n        const dotProduct = vec1.reduce((sum, val, i) =\u003e sum + val * (vec2[i] || 0), 0);\n        const magnitude1 = Math.sqrt(vec1.reduce((sum, val) =\u003e sum + val * val, 0));\n        const magnitude2 = Math.sqrt(vec2.reduce((sum, val) =\u003e sum + val * val, 0));\n        return magnitude1 \u0026\u0026 magnitude2 ? dotProduct / (magnitude1 * magnitude2) : 0;\n    }\n\n    private getWordSimilarity(word1: string, words: string[]): number {\n        const word1Vector = this.getWordVector(word1);\n        let maxSimilarity = 0;\n\n        for (const word2 of words) {\n            const word2Vector = this.getWordVector(word2);\n            const similarity = this.cosineSimilarity(word1Vector, word2Vector);\n            maxSimilarity = Math.max(maxSimilarity, similarity);\n        }\n\n        return maxSimilarity;\n    }\n\n    private scoreStringMatch(weight: number, text: string | undefined, query: string | undefined): number {\n        // Simple scoring mechanism: \n        // +2 point if it the same\n        // split into words: \n        //      TOTAL: +2/nb words\n        //          -0% point to total per exact word match (case insensitive)\n        //          -5% point to total if word query and word text have 80% similarity\n        //          -10% point to total if word query and word text have 50% similarity\n        //          -15% point to total if word query and word text have 30% similarity\n        //          -20% point to total if word query and word text have 10% similarity\n        //          -100% point to total if word query and word text have 0% similarity\n        // Higher score means better match\n        // below 0 means no match, Warn all my test were correct, but i didn't test them all\n\n        if (!text || !query) return 0;\n\n        text = text.toLowerCase();\n        query = query.toLowerCase();\n\n        let score = 0;\n        if (text === query)\n            return ScoreWeight.MaxScore * weight;\n\n        const textWords = text.split(\" \");\n        const queryWords = query.split(\" \");\n\n        for (const word of queryWords) {\n            if (textWords.includes(word)) {\n                score += ScoreWeight.MaxScore / textWords.length;\n            }\n            else {\n                const similarity = this.getWordSimilarity(word, textWords);\n                score -= similarity * ScoreWeight.MaxScore / textWords.length;\n            }\n        }\n\n        return score * weight;\n    }\n\n    private findBestTitle(movies: { Title: string; Url: string }[], opts: string): { Title: string; Url: string } | undefined {\n        let bestScore = 0;\n        let bestMovie: { Title: string; Url: string } | undefined;\n\n        for (const movie of movies) {\n            let score: number = 0;\n            let strOutput = \"\"\n            // TITLE\n            score += this.scoreStringMatch(2, movie.Title, opts);\n            strOutput += `Title: ${movie.Title} VS ${opts}, Current Score: ${score}\\n`;\n\n            console.log(`Movie: ${movie.Title}\\n${strOutput}Total Score: ${score}\\n--------------------`);\n\n            if (score \u003e bestScore) {\n                bestScore = score;\n                bestMovie = movie;\n            }\n        }\n\n        if (bestMovie) {\n            console.log(\"Best movie found:\", bestMovie);\n            return bestMovie;\n        }\n        return undefined;\n    }\n\n    private async findSubtitles(html: string, serverUrl: string, unpacked?: string): Promise\u003cVideoSubtitle[]\u003e {\n        let subtitles: VideoSubtitle[] = [];\n        const subtitleRegex = /\u003ctrack\\s+[^\u003e]*src=[\"']([^\"']+\\.vtt(?:\\?[^\"']*)?)[\"'][^\u003e]*\u003e/gi;\n        let trackMatches = html.matchAll(subtitleRegex);\n\n        for (const match of trackMatches) {\n            const src = match[1];\n            const fullTag = match[0];\n\n            let url = src.startsWith(\"http\") ? src : `${serverUrl.split(\"/\").slice(0, 3).join(\"/\")}${src}`;\n\n            // Attempt to extract language info\n            const langMatch = fullTag.match(/(?:label|srclang)=[\"']?([a-zA-Z\\-]{2,})[\"']?/i);\n            const langCode = langMatch?.[1]?.toLowerCase() || \"\";\n\n            const language = languageMap[langCode] || langCode || \"Unknown\";\n\n            const isDefault = /default/i.test(fullTag);\n\n            subtitles.push({\n                id: `sub-${subtitles.length}`,\n                url,\n                language,\n                isDefault,\n            });\n        }\n\n        // Fallback: look for direct .vtt URLs (if \u003ctrack\u003e not used)\n        if (subtitles.length === 0) {\n            const rawSubtitleRegex = /https?:\\/\\/[^\\s'\"]+\\.vtt(?:\\?[^'\"\\s]*)?/g;\n            let subtitleMatches = html.match(rawSubtitleRegex) || unpacked?.match(rawSubtitleRegex) || [];\n\n            if (subtitleMatches.length \u003e 0) {\n                if (!subtitleMatches.some(url =\u003e url.startsWith(\"http\"))) {\n                    const baseUrl = serverUrl.split(\"/\").slice(0, 3).join(\"/\");\n                    subtitleMatches = subtitleMatches.map(url =\u003e `${baseUrl}${url}`);\n                }\n\n                subtitles = subtitleMatches.map((url, idx) =\u003e {\n                    const filename = url.split(\"/\").pop() || \"\";\n                    const codeMatch = filename.match(/([a-z]{2,3})(?=\\.vtt)/i);\n                    const langCode = codeMatch?.[1]?.toLowerCase() || \"\";\n                    const language = languageMap[langCode] || langCode || \"Unknown\";\n\n                    return {\n                        id: `sub-${idx}`,\n                        url,\n                        language,\n                        isDefault: idx === 0,\n                    };\n                });\n            }\n        }\n\n        if (subtitles) {\n            console.log(\"Subtitles found:\", subtitles);\n        }\n\n        return subtitles;\n    }\n\n    private async findMediaUrls(type: VideoSourceType, html: string, serverUrl: string, resolutionMatch?: RegExpMatchArray | null, unpacked?: string): Promise\u003cVideoSource[] | VideoSource | undefined\u003e {\n\n        // const teststring = `\"});player.src([{src: \"/v/67d93a886482187aabca6fded5ce8b1b/5964336.mp4\", type`\n        const regex = new RegExp('https?:\\\\/\\\\/[^\\'\"]+\\\\.' + type + '(?:\\\\?[^\\\\s\\'\"]*)?(?:#[^\\\\s\\'\"]*)?', 'g');\n        let VideoMatch = html.match(regex)\n            || unpacked?.match(regex)\n            || html.match(new RegExp(`\"([^\"]+\\\\.${type})\"`, \"g\"))\n            || unpacked?.match(new RegExp(`\"([^\"]+\\\\.${type})\"`, \"g\"))\n\n        if (VideoMatch) {\n            if (!VideoMatch.some(url =\u003e url.startsWith(\"http\"))) {\n                const serverurldomain = serverUrl.split(\"/\").slice(0, 3).join(\"/\");\n                VideoMatch = VideoMatch.map(url =\u003e `${serverurldomain}${url}`.replaceAll(`\"`, \"\"));\n            }\n\n            if (VideoMatch.length \u003e 1) {\n                // If found multiple, euhm we are cooked... idk yet let me think of it lmao\n                console.warn(`Found multiple ${type}`);\n            }\n            else {\n                console.log(`Found ${type} URL:`, VideoMatch[0]);\n            }\n\n            if (!VideoMatch)\n                return undefined;\n\n            for (const index in VideoMatch) {\n\n                console.log(`PROCESSING: ${VideoMatch[index].substring(0, 50)}...`)\n                if (VideoMatch[index].includes(`master.${type}`)) {\n                    // fetch the match to see if the m3u8 is main or extension\n                    // get the referer of the ServerUrl\n                    const ref = serverUrl.split(\"/\").slice(0, 3).join(\"/\");\n                    const req = await fetch(`${this.SEANIME_API}${encodeURIComponent(VideoMatch[index])}`);\n                    let reqHtml = await req.text();\n                    reqHtml = decodeURIComponent(reqHtml);\n                    let qual = \"\";\n                    let url = \"\";\n                    const videos: VideoSource[] = [];\n                    if (reqHtml.includes(\"#EXTM3U\")) {\n                        reqHtml.split(\"\\n\").forEach(line =\u003e {\n                            if (line.startsWith(\"#EXT-X-STREAM-INF\")) {\n                                qual = line.split(\"RESOLUTION=\")[1]?.split(\",\")[0] || \"unknown\";\n                                const height = parseInt(qual.split(\"x\")[1]) || 0;\n\n                                if (height \u003e= 1080) {\n                                    qual = \"1080p\";\n                                } else if (height \u003e= 720) {\n                                    qual = \"720p\";\n                                } else if (height \u003e= 480) {\n                                    qual = \"480p\";\n                                } else if (height \u003e= 360) {\n                                    qual = \"360p\";\n                                } else {\n                                    qual = \"unknown\";\n                                }\n                                console.log(\"Quality Found: \" + qual)\n                            }\n                            else if (!line.startsWith(\"#\")) {\n                                url = line.replace(\"/api/v1/proxy?url=\", \"\");\n                                if (!VideoMatch)\n                                    return undefined\n                                if(!url.startsWith(\"http\"))\n                                {\n                                    const baseUrl = VideoMatch[index].substring(0, VideoMatch[index].lastIndexOf('/'))\n                                    url = baseUrl +\"/\"+ url\n                                }\n                                console.log(url)\n                            }\n\n                            if (url \u0026\u0026 qual) {\n                                videos.push({\n                                    url: url,\n                                    type: type,\n                                    quality: `${this._Server} - ${qual}`,\n                                    subtitles: []\n                                })\n                                url = \"\";\n                                qual = \"\";\n                            }\n                        });\n                    }\n                    else {\n                        console.warn(`${type} doesn't have #EXTM3U`)\n                    }\n\n                    if (videos.length \u003e 0) {\n                        for (const video of videos) {\n                            video.subtitles = await this.findSubtitles(html, serverUrl, unpacked);\n                        }\n                        return videos.sort((a, b) =\u003e {\n                            const resolutionOrder = [\"1080p\", \"720p\", \"480p\", \"360p\", \"unknown\"];\n                            const aIndex = resolutionOrder.indexOf(a.quality.split(\" \")[2]);\n                            const bIndex = resolutionOrder.indexOf(b.quality.split(\" \")[2]);\n                            return aIndex - bIndex;\n                        });\n                    }\n                    else {\n                        console.warn(`${type} master is not in a correct format`)\n                        continue\n                    }\n                }\n                else if (type !== \"mp4\") {\n                    console.warn(`No ${type} master URL found`);\n                    continue\n                }\n\n                console.log(\"return: \" + VideoMatch[index])\n                return {\n                    url: VideoMatch[index],\n                    quality: resolutionMatch ? resolutionMatch[1] : `${this._Server} - unknown`,\n                    type: type,\n                    subtitles: await this.findSubtitles(html, serverUrl, unpacked)\n                };\n            }\n        }\n\n        return undefined;\n    }\n\n    private async HandleServerUrl(serverUrl: string): Promise\u003cVideoSource[] | VideoSource\u003e {\n        const reqNoProxy = await fetch(serverUrl)\n        let req;\n\n        if (!reqNoProxy.ok) {\n            req = await fetch(`${this.SEANIME_API}${encodeURIComponent(serverUrl)}`);\n\n            if (!req.ok) {\n                console.log(\"Failed to fetch server URL:\", serverUrl, \"Status:\", req.status);\n                return [];\n            }\n        }\n        else {\n            req = reqNoProxy\n        }\n\n        const html = await req.text();\n\n        // special case Dean Edwards’ Packer\n        // .match(/eval\\(function\\(p,a,c,k,e,d\\)(.*?)\\)\\)/s);\n        function unpack(p: string, a: number, c: number, k: string[]) { while (c--) if (k[c]) p = p.replace(new RegExp('\\\\b' + c.toString(a) + '\\\\b', 'g'), k[c]); return p }\n        // regex is weird here so i did it manually\n        function extractScripts(str: string): string[] {\n            const results: string[] = [];\n            const openTag = \"\u003cscript type='text/javascript'\u003e\";\n            const closeTag = \"\u003c/script\u003e\";\n\n            let pos = 0;\n\n            while (pos \u003c str.length) {\n                const start = str.indexOf(openTag, pos);\n                if (start === -1) break;\n                const end = str.indexOf(closeTag, start);\n                if (end === -1) break;\n                const content = str.substring(start + openTag.length, end);\n                results.push(content);\n                pos = end + closeTag.length;\n            }\n\n            return results;\n        }\n\n        let unpacked;\n        const scriptContents = extractScripts(html);\n        for (const c of scriptContents) {\n            let c2 = c;\n            // change c for each 200 char put \\n (it too long)\n            for (let j = 0; j \u003c c.length; j += 900) {\n                c2 = c2.substring(0, j) + \"\\n\" + c2.substring(j);\n            }\n            if (c.includes(\"eval(function(p,a,c,k,e,d)\")) {\n\n                console.log(\"Unpacked has been found.\");\n                const fullRegex = /eval\\(function\\([^)]*\\)\\{[\\s\\S]*?\\}\\(\\s*'([\\s\\S]*?)'\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*'([\\s\\S]*?)'\\.split\\('\\|'\\)/;\n                const match = c2.match(fullRegex);\n\n                if (match) {\n                    const packed = match[1];\n                    const base = parseInt(match[2], 10);\n                    const count = parseInt(match[3], 10);\n                    const dict = match[4].split('|');\n\n                    unpacked = unpack(packed, base, count, dict);\n                    // decode unicode example \\uXXXX\n                    unpacked = unpacked.replace(/\\\\u([\\d\\w]{4})/gi, (_, grp) =\u003e String.fromCharCode(parseInt(grp, 16)))\n                        .replace(/%3C/g, '\u003c').replace(/%3E/g, '\u003e')\n                        .replace(/%3F/g, '?')\n                        .replace(/%3A/g, ':')\n                        .replace(/%2C/g, ',')\n                        .replace(/%2F/g, '/')\n                        .replace(/%2B/g, '+')\n                        .replace(/%20/g, ' ')\n                        .replace(/%21/g, '!')\n                        .replace(/%22/g, '\"')\n                        .replace(/%27/g, \"'\")\n                        .replace(/%28/g, '(').replace(/%29/g, ')')\n                        .replace(/%3B/g, ';');\n                }\n            }\n        }\n\n        const resolutionRegex = /(?:^|[^a-zA-Z0-9])(\\d{3,4})p(?=[^a-zA-Z0-9]|$)/;\n        const resolutionMatch =\n            html.match(resolutionRegex) ||\n            unpacked?.match(resolutionRegex);\n\n        if (resolutionMatch) {\n            const resolution = resolutionMatch[1];\n            console.log(\"Found resolution:\", resolution);\n        }\n\n        // look for .m3u8\n        const m3u8Videos = await this.findMediaUrls(\"m3u8\", html, serverUrl, resolutionMatch, unpacked);\n        if (m3u8Videos !== undefined) {\n            console.log(\"Found m3u8: \", m3u8Videos);\n            return m3u8Videos;\n        }\n\n        // look for .mp4 do the same as .m3u8\n        const mp4Videos = await this.findMediaUrls(\"mp4\", html, serverUrl, resolutionMatch, unpacked);\n        if (mp4Videos !== undefined) {\n            console.log(\"Found mp4: \", mp4Videos);\n            return mp4Videos;\n        }\n\n        console.warn(\"No m3u8 or mp4 URLs found in the server URL:\", serverUrl, \". Make sure this is true.\");\n        return [];\n    }\n\n    //#endregion\n\n    //#region main\n\n    async search(opts: SearchOptions): Promise\u003cSearchResult[]\u003e {\n        if (opts.query === opts.media.romajiTitle \u0026\u0026 opts.media.romajiTitle !== opts.media.englishTitle)\n            return []\n\n        const Lang = opts.dub ? \"vf\" : \"vostfr\";\n        const queryEnglish = opts.media.englishTitle || opts.query;\n\n        const RegexSeasonProvider = /saison\\s*(\\d+)/i;\n        const RegexPartProvider = /partie\\s*(\\d+)/i;\n        const RegexNumProvider = /(\\d+)/;\n\n        const RegexSeasonOpts = queryEnglish.toLowerCase().match(/season\\s*(\\d+)/i);\n        const RegexNumOpts = queryEnglish.toLowerCase().match(/(\\d+)/);\n        const RegexPartOpts = queryEnglish.toLowerCase().match(/part\\s*(\\d+)/i);\n\n        let seasonNumberOpts: number | undefined = RegexSeasonOpts ? parseInt(RegexSeasonOpts[1]) :\n            opts.media.format === \"TV\" \u0026\u0026 RegexNumOpts ? parseInt(RegexNumOpts[1]) : undefined;\n\n        let partNumberOpts: number | undefined = RegexPartOpts ? parseInt(RegexPartOpts[1]) : undefined;\n\n        const queryVariants = this.generateQueryVariants(opts.query, opts.query.trim().split(/[\\s:']+/).length);\n\n        const searchPagePromises = queryVariants.map(async (variant) =\u003e {\n            const bodyData = new URLSearchParams({\n                do: \"search\",\n                subaction: \"search\",\n                full_search: \"0\",\n                result_from: \"1\",\n                story: variant\n            });\n\n            const html = await fetch(this.SEARCH_URL, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/x-www-form-urlencoded\",\n                    \"Origin\": \"https://animesultra.org\",\n                    \"Referer\": \"https://animesultra.org/\",\n                },\n                body: bodyData.toString()\n            }).then(res =\u003e res.text());\n\n            return { html, variant };\n        });\n\n        const results = await Promise.all(searchPagePromises);\n\n        for (const { html, variant } of results) {\n            const $ = await LoadDoc(html);\n            const movies = $(\"div#dle-content .flw-item\");\n\n            if (movies.length() === 0) continue;\n\n            const movieList: { Title: string; Url: string }[] = [];\n\n            for (let i = 0; i \u003c movies.length(); i++) {\n                const el = movies.eq(i);\n\n                if (el.find(\"div.tick-dub\").text().toLowerCase() !== Lang) continue;\n\n                const Poster = el.find(\"a.film-poster-ahref\");\n                const title = Poster.attr(\"title\")?.trim() || \"\";\n                const url = Poster.attr(\"href\")?.trim() || \"\";\n\n                if (title \u0026\u0026 url) {\n                    const LowerCase = title.toLowerCase();\n\n                    const seasonMatch = LowerCase.match(RegexSeasonProvider);\n                    const partMatch = LowerCase.match(RegexPartProvider);\n                    const Num = LowerCase.match(RegexNumProvider);\n\n                    const seasonNum = seasonMatch ? parseInt(seasonMatch[1]) : null;\n                    const partNum = partMatch ? parseInt(partMatch[1]) : null;\n                    const onylNum = Num ? parseInt(Num[1]) : null;\n\n                    if ((seasonNumberOpts \u0026\u0026 seasonNumberOpts === seasonNum) ||\n                        (partNumberOpts \u0026\u0026 partNumberOpts === partNum) ||\n                        (seasonNumberOpts \u0026\u0026 seasonNumberOpts === onylNum)) {\n                        movieList.push({ Title: title, Url: url });\n                    }\n                }\n            }\n\n            const bestMovie = this.findBestTitle(movieList, opts.query);\n            if (bestMovie) {\n                return [{\n                    id: bestMovie.Url.split(\"/\").pop()!.split(\"-\")[0],\n                    title: bestMovie.Title,\n                    url: bestMovie.Url,\n                    subOrDub: opts.dub ? \"dub\" : \"sub\",\n                }];\n            }\n        }\n\n        return [];\n    }\n\n    async findEpisodes(id: string): Promise\u003cEpisodeDetails[]\u003e {\n        console.log(`${this.EPISODE_URL}newsId=${id}\u0026d=${new Date().getTime()}`);\n\n        const $ = await fetch(`${this.EPISODE_URL}newsId=${id}\u0026d=${new Date().getTime()}`)\n            .then(res =\u003e res.text())\n            .then(text =\u003e JSON.parse(text))\n            .then(json =\u003e json.html)\n            .then(LoadDoc);\n\n        const ServerToAdd: string[] = [];\n        const epsUrl = $(\".ep-item\");\n\n        const episodeDetails = await Promise.all(\n            epsUrl.map(async (_, el) =\u003e {\n                const href = el.attr(\"href\");\n                const title = el.attr(\"title\");\n                const episodeId = el.attr(\"data-id\");\n                const episodeNumber = parseInt(el.attr(\"data-number\") || \"0\");\n\n                if (!href || !episodeId) return undefined;\n\n                const episodeDoc = await fetch(href)\n                    .then(req =\u003e req.text())\n                    .then(LoadDoc);\n\n                const serverItems = episodeDoc(\".server-item\");\n                let Servers = \"\";\n\n                serverItems.each((_, serverEl) =\u003e {\n                    const serverId = serverEl.attr(\"data-server-id\");\n                    if (!serverId) return;\n\n                    const playerSelector = `#content_player_${serverId}`;\n                    const playerElement = $(playerSelector);\n                    let urlServer = playerElement.text().trim();\n                    if (/^\\d+$/.test(urlServer)) {\n                        urlServer = `https://video.sibnet.ru/shell.php?videoid=${urlServer}`;\n                    }\n                    if (Servers === \"\")\n                        Servers = urlServer\n                    else\n                        Servers += \",\" + urlServer\n\n                    if (urlServer \u0026\u0026 DevMode) {\n                        for (const element of urlServer.trim().replace(/,$/, \"\").split(\",\")) {\n                            // get the server name of the element\n                            const parts = element.split(\"/\");\n\n                            const PartsServerName = parts[2] ? parts[2].split(\".\") : [];\n                            const serverName = PartsServerName.length \u003e= 3 ? PartsServerName[1] : PartsServerName[0];\n                            // check if servername is in the list of the episode servers\n                            if (serverName !== undefined \u0026\u0026 !this.getSettings().episodeServers.includes(serverName) \u0026\u0026 !ServerToAdd.includes(serverName)) {\n                                ServerToAdd.push(serverName);\n                            }\n                        }\n                    }\n                });\n\n                const episode: EpisodeDetails = {\n                    id: Servers,\n                    number: episodeNumber,\n                    url: href,\n                    title,\n                };\n\n                return episode;\n            })\n        );\n\n        if (DevMode \u0026\u0026 ServerToAdd.length \u003e 0) {\n            console.warn(`Need to add server(s): \"${ServerToAdd.join(`\",\"`)}\"`);\n            this.getSettings().episodeServers.push(...ServerToAdd);\n        }\n\n\n        return episodeDetails.filter((ep): ep is EpisodeDetails =\u003e !!ep);\n    }\n\n    async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise\u003cEpisodeServer\u003e {\n        this._Server = _server;\n        const servers = episode.id.split(\",\");\n        const serverUrls = servers.filter(server =\u003e server.includes(_server));\n        const videoSources: VideoSource[] = [];\n\n        if (serverUrls.length \u003e 0 \u0026\u0026 _server !== \"\") {\n\n            const PromiseResult = await Promise.all(\n                serverUrls.map(async url =\u003e {\n                    return await this.HandleServerUrl(url);\n                })\n            );\n\n            videoSources.push(...PromiseResult.flat())\n\n        } else {\n            console.log(`Server not found: ${_server}\\n Try with these servers:\\n- ${servers.map(url =\u003e {\n                const parts = url.split(\"/\");\n                const partsServerName = parts[2] ? parts[2].split(\".\") : [];\n                const serverName = partsServerName.length \u003e= 3 ? partsServerName[1] : partsServerName[0];\n                return serverName;\n            }).join(\"\\n- \")}`);\n\n            return {\n                headers: {},\n                server: \"\",\n                videoSources: []\n            } as EpisodeServer;\n        }\n\n        if (videoSources.length \u003e 0) {\n            // take the [0] no matter what they have the same ref\n            const ref = serverUrls[0].split(\"/\").slice(0, 3).join(\"/\");\n            return {\n                headers: {\n                    referer: ref\n                },\n                server: _server,\n                videoSources: videoSources\n            } as EpisodeServer;\n        } else {\n            console.warn(`No video sources found for server: ${_server}`);\n            return {\n                headers: {},\n                server: `${_server} (video not found)`,\n                videoSources: [{\n                    url: \"https://devstreaming-cdn.apple.com/videos/streaming/examples/img_bipbop_adv_example_fmp4/master.m3u8\",\n                    type: \"m3u8\",\n                    quality: \"video not found\",\n                    subtitles: []\n                }]\n            } as EpisodeServer;\n        }\n    }\n\n\n    //#endregion\n}"
}
